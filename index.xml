<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jlouis&#39; Ramblings</title>
    <link>https://jlouis.github.io/</link>
    <description>Recent content on jlouis&#39; Ramblings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; Jesper Louis Andersen 2007-2018</copyright>
    <lastBuildDate>Sun, 01 Dec 2013 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://jlouis.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Erlang Shell</title>
      <link>https://jlouis.github.io/posts/the-erlang-shell/</link>
      <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/the-erlang-shell/</guid>
      <description>(Front Line Assembly: Civilization, Eastern Sun: In Emptiness)
 As an Erlang programmer I often claim that &amp;#8220;You can’t pick parts of Erlang and then claim you have the same functionality. It all comes together as a whole&amp;#8221;. This is true for many programming environments where the main components are built to be orthogonal from each other and the parts form the cohesive whole. A good example of this approach would be Go as well.</description>
    </item>
    
    <item>
      <title>Glicko2 Benchmarking (1)</title>
      <link>https://jlouis.github.io/posts/glicko2-benchmarking-1/</link>
      <pubDate>Sat, 16 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/glicko2-benchmarking-1/</guid>
      <description>One of my hobby projects is to run statistics on Quake Live Duel matches. I began collecting data around 1st of Feb 2013 and now I have scraped around \($2.5$\) Million duel matches. This allows me to play with different ranking methods on the players and gauge their ranking.
  The ranking system I use is called Glicko2, devised by Mark E. Glickman (http://glicko.net). The system is like the chess rating system ELO, except that it is newer and avoids certain problems with ELO.</description>
    </item>
    
    <item>
      <title>On Logbooks</title>
      <link>https://jlouis.github.io/posts/on-logbooks/</link>
      <pubDate>Mon, 11 Nov 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/on-logbooks/</guid>
      <description>My friend, Michael T. Richter, presented me with a nice concept from engineering. The logbook. The concept is extremely simple: you keep a log of your work, so you can refer back to it later. Yet, there are relatively few in Computer Science who does that, which is a sad state of affairs.
 The odd thing is that most computer scientists do know the importance of logging in an application.</description>
    </item>
    
    <item>
      <title>Eventi</title>
      <link>https://jlouis.github.io/posts/eventi/</link>
      <pubDate>Wed, 30 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/eventi/</guid>
      <description>So, listening a bit to &amp;#8220;The Civil Wars&amp;#8221; this afternoon cooked up the rest of eVenti. This blog post is brought to you by Maurice Ravel, and Morcheeba however.[1]
 The eVenti system is a simple Erlang-implementation of the venti(8) system famous from Plan9. The idea is very simple: We can store data in Venti and the data becomes addressed by its SHA1 checksum.footenote:[I should probably change this later, but for compatibility reasons we stick to it…] This is called a Content Adressable Storage (CAS) because Content is—you guessed it—addressed by the checksum of the content.</description>
    </item>
    
    <item>
      <title>Why I use erlang.mk</title>
      <link>https://jlouis.github.io/posts/why-erlang-mk/</link>
      <pubDate>Mon, 28 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/why-erlang-mk/</guid>
      <description>Here is our typical Erlang project. And note we are on a pretty slow Mac OSX filesystem and a 5400 RPM disk. Not the fastest in the world. If I run a rebar-compile from cold, we get the following a timing of 26 seconds. Doing the same with erlang.mk is 24 seconds. Note that erlang.mk only uses one thread, whereas rebar is parallelizing the build and is using all 4 cores in the machine.</description>
    </item>
    
    <item>
      <title>An Evil Postgres Bug</title>
      <link>https://jlouis.github.io/posts/evil-postgres-bug/</link>
      <pubDate>Mon, 07 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/evil-postgres-bug/</guid>
      <description>So, I have this QLGlicko project. It consists of a web scraper which takes in duel matches played in the game of Quake Live—and stores them in a Postgres database. These duels are then analyzed and I run the Glicko 2 (see http://glicko.net/) ranking system on them to tell people who are currently the best player on a given map.
 The system works well, but I was tired of maintaining it on a Linux machine for several reasons.</description>
    </item>
    
    <item>
      <title>An Initial Post</title>
      <link>https://jlouis.github.io/posts/an-initial-post/</link>
      <pubDate>Wed, 02 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/an-initial-post/</guid>
      <description>I tend to stir up things over on blogger, mostly writing the blog http://jlouisramblings.blogspot.com/ —but I am considering writing and using Medium instead to provide stuff, since the platform just seems nicer. My Ramblings are mostly-technical and they tend to contain a lot of code in them, but the way I tend to add new blog posts is somewhat indirect. I write the post itself in my trusty Acme editor—as markdown—and then I convert that into HTML which I then push in on top of Blogger.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://jlouis.github.io/posts/glicko2-benchmarking-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jlouis.github.io/posts/glicko2-benchmarking-2/</guid>
      <description>57—Glicko 2 Benchmarking (2013-12-22) Glicko2 is a ranking system for duel games. I use it to rank Quake Live duels. The idea is to find a value, the strength of a player, called R in the system. The higher the R value, the better the player.
How does Glicko2 estimate R? It looks at historical data and uses bayesian methods to estimate the current strength of a player. Like all other systems, there are parameters we can tune for a set of players and a set of duels:</description>
    </item>
    
  </channel>
</rss>