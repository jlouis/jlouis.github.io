<!doctype html>

<html lang="en">

<head>
  <title>Why I use erlang.mk - jlouis&#39; Ramblings</title>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="description" content="The HTML5 Herald" />
<meta name="author" content="Jesper Louis Andersen" /><meta property="og:title" content="Why I use erlang.mk" />
<meta property="og:description" content="Here is our typical Erlang project. And note we are on a pretty slow Mac OSX filesystem and a 5400 RPM disk. Not the fastest in the world. If I run a rebar-compile from cold, we get the following a timing of 26 seconds. Doing the same with erlang.mk is 24 seconds. Note that erlang.mk only uses one thread, whereas rebar is parallelizing the build and is using all 4 cores in the machine." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jlouis.github.io/posts/why-erlang-mk/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-10-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2013-10-28T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Why I use erlang.mk"/>
<meta name="twitter:description" content="Here is our typical Erlang project. And note we are on a pretty slow Mac OSX filesystem and a 5400 RPM disk. Not the fastest in the world. If I run a rebar-compile from cold, we get the following a timing of 26 seconds. Doing the same with erlang.mk is 24 seconds. Note that erlang.mk only uses one thread, whereas rebar is parallelizing the build and is using all 4 cores in the machine."/>

<meta name="generator" content="Hugo 0.84.1" />
    

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css" integrity="sha256-l85OmPOjvil/SOvVt3HnSSjzF1TUMyT9eV0c2BzEGzU=" crossorigin="anonymous" />
  <link rel="stylesheet" href="https://jlouis.github.io/fontawesome/css/all.min.css" />
  
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab|Ruda" />
  
  
  <link rel="stylesheet" type="text/css" href="/css/styles.css" /></head>

<body>
  <div id="container">
    <header>
      <h1>
                <a href="/">jlouis' Ramblings</a>
            </h1>

      <ul id="social-media">
             <li>
               <a href="https://github.com/jlouis" title="GitHub">
               <i class="fab fa-github fa-lg"></i>
               </a>
             </li>
             <li>
               <a href="https://twitter.com/jlouis666" title="Twitter">
               <i class="fab fa-twitter fa-lg"></i>
               </a>
             </li>
      </ul>
      
      <p><em>Musings on tech, software, and other things</em></p>
      
    </header>

    
<nav>
    <ul>
        
    </ul>
</nav>


    <main>




<article>

    <h1>Why I use erlang.mk</h1>

    
      <aside>
    <ul>
        <li>
            <time class="post-date" datetime="2013-10-28T00:00:00Z">Oct 28, 2013</time>
        </li>
        
        

        

        <li>2 minute read</li>
    </ul>
</aside>

    

    


    <div class="paragraph">
<p>Here is our typical Erlang project. And note we are on a pretty slow Mac
OSX filesystem and a 5400 RPM disk. Not the fastest in the world. If I
run a rebar-compile from cold, we get the following a timing of 26
seconds. Doing the same with erlang.mk is 24 seconds. Note that
erlang.mk only uses one thread, whereas rebar is parallelizing the build
and is using all 4 cores in the machine. But erlang.mk only spawns the
erlc compiler once per directory, and only if it needs to—no change
means no spawn.</p>
</div>
<div class="paragraph">
<p>But if we have already compiled the code, the numbers are much
different. When compiling from warm, it takes rebar 9 seconds to figure
out that there is nothing to do in the project. erlang.mk does the same
thing in 0.2 seconds.</p>
</div>
<div class="paragraph">
<p>When developing, I don’t want to wait on the compile to finish all the
time. I want it to be proportional to the amount of change in my
repository, not on the complexity of the software project.</p>
</div>
<div class="paragraph">
<p>The other reason is that make(1) is the right tool for the job. Most of
these other tools are reinventions of the thing make(1) does. And it is
very hard to even contend with a tool that has survived so many years
and is so archaic.</p>
</div>


</article>


<section class="post-nav">
    <ul>
        
        <li>
            <a href="https://jlouis.github.io/posts/evil-postgres-bug/"><i class="fa fa-chevron-circle-left"></i> An Evil Postgres Bug</a>
        </li>
        
        
        <li>
            <a href="https://jlouis.github.io/posts/glicko2-benchmarking-2/">Glicko 2 Benchmarking <i class="fa fa-chevron-circle-right"></i> </a>
        </li>
        
    </ul>
</section>
  
    
    
  





</main>
    <footer>
        <h6> |
            Rendered by <a href="https://gohugo.io" title="Hugo">Hugo</a> |
            <a href="https://jlouis.github.io/index.xml">Subscribe </a></h6>
    </footer>
</div>
<script src="/js/scripts.js"></script>


</body>

</html>

