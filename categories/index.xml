
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
 <channel>
   <title>Categories on jlouis&#39; Ramblings</title>
   <link>https://jlouis.github.io/categories/</link>
   <description>Recent content in Categories on jlouis&#39; Ramblings</description>
   <generator>Hugo -- gohugo.io</generator>
   
       <atom:link href="https://jlouis.github.io/categories/index.xml" rel="self" type="application/rss+xml" />
   
   
     <item>
       <title>On Observability</title>
       <link>https://jlouis.github.io/posts/observability/</link>
       <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/observability/</guid>
       <description>&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The hard part is not debugging the code. The hard part is figuring out where the bug is. This is what observability is.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div class=&#34;attribution&#34;&gt;— Charity Majors&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I really like the notion of “observability”, which stems from Control Theory. The idea is that we have some system, with inputs, some internal state and some outputs. A system is observable if we can determine its internal state, solely from a finite set of outputs (in finite time).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The contrast, a non-observable system, has some internal state we cannot infer just by looking at the outputs over some time frame.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Credit should be given to Charity Majors for transplanting this idea into tech (thank you!), and also creating a whole company around the idea (see &lt;a href=&#34;http://honeycomb.io&#34; class=&#34;bare&#34;&gt;http://honeycomb.io&lt;/a&gt; if you are interested).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When we look at program output, we need to take a (w)holistic approach. There are the immediate replies to user requests; but there are also log lines, trace probes, metrics and so on. Everything can be considered an output, even if it is a side-effect of the primary computation. And that set is what we look at when we try to determine what is happening inside a running system.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Most computer systems are strictly non-observable. We don’t log the relevant information, we don’t have the relevant metrics, and we don’t have the ability to trace arbitrarily in most systems. As a result, we have no chance when a system misbehaves. In many cases we won’t even know that the system misbehaved in some way.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Logs, Metrics and Tracing are &lt;em&gt;necessary&lt;/em&gt; but certainly not &lt;em&gt;sufficient&lt;/em&gt; properties needed to achieve observability in a system. People will do all kinds of aggregations, filters, reductions and so on to their data in order to cut down on it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Logs tend to have all kinds of problems associated with them. The good old syslog system has the problem it treats each line as a separate event. It also has no structure in the log lines. Asking questions in these are hell. A little better is if the log lines has structure, where the structure is flat. But the best situation is if you just log an Erlang term, and S-expression or the like, so you have all relevant information in the log line.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Metrics tend to aggregate. You know you had an error, but you don’t know any context. You also tend to have a temporal problem, in which you take 30 seconds of errors and store in one value. This makes spikes impossible to detect.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When people say tracing, they often mean “We added this static set of probe points to our code base, and we want to output all of those when we increase the log level.” People don’t enable this because it kills their production servers with on-disk log writes.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;How we transplant the notion from control theory is a bit vague:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;We could treat the notion as a continous axis where systems can converge toward being (fully) observable.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We could treat the notion as a discrete property. Either you have a system which is, or you have a system which isn’t.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We could accept a discrete notion, but with partiality. In some cases our system is observable, but not in others. Then define a fully observable system as one which is observable in all cases.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Personally, I lean toward the latter of these. Suppose you have a fault in your software. If the fault can be found and fixed by looking at your systems output only, then the system was observable in this case. If, on the other hand, you need to reproduce the error in a development environment, attach a debugger, step through the program and scratch your head for several hours, the system was not observable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I stress this is on a case-by-case basis. A system is 80% fault-observable if 80% of all faults are observable according to the above notion.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_crash_logs&#34;&gt;Crash Logs&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In Erlang systems, faults generate crashes. A crash log contains:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;The current stack trace of the failing process&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The last event the process received&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The state of the process &lt;em&gt;before&lt;/em&gt; processing said event&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;My experience is that often, this is enough to provide observability in a fault scenario. You can work from the state and figure out how the event might have lead to the stack trace. In particular you can often figure out what code path was taken and how that would lead to the faulty situation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Most other systems has a state space which are several gigabytes in size. So small dumps like these are &lt;em&gt;impossible&lt;/em&gt; since we cannot find the relevant piece of information. In contrast, process isolation in Erlang can often limit us to the core state for the fault.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;What you &lt;em&gt;can&lt;/em&gt; and should do, however, is to take all coredumps and move these into persistent storage. If your core dump dies with your container, you have no post-mortem debugging and you will not be wiser. In some situations, if you can detect the fault, you can force the core-dump so you have a state you can inspect.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_assertions&#34;&gt;Assertions&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;If you assert your invariants in your code, then Erlang systems will crash if an invariant is broken, which leads to crash logs for the faulty process. Erlang systems often assert processing as they are executing. This vastly increases cases where the system is observable. As an example, suppose you open a file on disk. You assert that you successfully open the file. If any error occurs, this produces output which allows you to observe the fault.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The key insight is that you don’t know which kind of fault is occurring. It could be that the file is not existent. Or you don’t have access to the file. So by asserting on any non-successful return, you get to learn important information necessary for internal-state-reconstruction. This information is added to the context of the crash log. In erlang systems you often see &lt;code&gt;{ok, _} = file:open(FName)&lt;/code&gt; which asserts the intended operation.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_dynamic_tracing&#34;&gt;Dynamic Tracing&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Tools such as dTrace, eBPF, and the built-in Erlang tracer are tools which can make a system observable. If a fault is detected, you can trace the fault in detail and capture enough information about the fault such that it becomes observable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note that the system doesn’t start out as being observable. You often encounter the fault, and scratch your head. Then you add tracing which is specific to a user-id, or a type of request. This trace is what changes the system, dynamically, from a non-observable system to one that is. Once the fault has been dealt with, you can go back and disable tracing.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Tracing is dynamic though. You cannot just add some extra lines to the code and then redeploy to capture the problem. You need to be able to change the system while it is in operation, and without having an impact on the system. The reason this is important is because the system might reset itself under a redeploy. Suppose you have a data structure which some times ends up in a pathological state making your system slow. If you redeploy, you reset this data structure, so now you cannot figure out why it is slow. This is why you need to be able to query the system dynamically.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Also, the impact of adding tracing must be proportional to the haystack/needle problem you have. If you add tracing for a specific customer, we cannot have this affecting any other customer in the system. It might take weeks before we hit the fault again, so we need to have this enabled for a while. If tracing impacts the system efficiency, people won’t enable it in production. And all really interesting errors occur in production.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_cardinality&#34;&gt;Cardinality&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Consider the following:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;I know a web request happened&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I know a web request happened, and I know if it was &lt;code&gt;2xx&lt;/code&gt;, &lt;code&gt;4xx&lt;/code&gt;, &lt;code&gt;5xx&lt;/code&gt; or something else&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I know a web request happened, and I know the exact status code&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The last case of these can be used to derive the other two. But not vice versa. The last case also needs to store more information, because it needs to discriminate the exact status code. Now consider:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;I know the user id of the web request&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;If we have a million users, the space of possible values has a cardinality of a million. Storing this efficiently is non-trivial in most current systems. However, it is paramount to get a scenario where we can observe the system.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Experience Report: Bidirectional type checking of GraphQL</title>
       <link>https://jlouis.github.io/posts/graphql-bidir-type-check/</link>
       <pubDate>Sun, 28 Apr 2019 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/graphql-bidir-type-check/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The core idea of GraphQL is this: let clients have a small, typed,total, functional (declarative) language where they can push programs tothe server side. The server then interprets these programs andprovides data to the client. The natural core for this is a lambdacalculus: a GraphQL &lt;em&gt;fragment&lt;/em&gt; is a lambda over the free variables ofthat fragment, for instance. A &lt;em&gt;query&lt;/em&gt; is also a lambda, but novariables are free, and it is “exported” for others to use. The onlyreason it &lt;em&gt;isn’t&lt;/em&gt; a full functional core is because the currentlanguage is more familiar to typical client programmers.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sidebarblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;Aside:&lt;/em&gt; GraphQL is the ultimate function-as-a-service implementation.In typical &lt;em&gt;serverless&lt;/em&gt; implementations of the FaaS scheme a clientcan execute a singular function on the server side at a time, withoutcaring about the underlying server infrastrucutre and its maintenance.GraphQL amends this by having the client push a program to the serverside, so part of the client runs server-side, using the predeterminedfunctions in the GraphQL Schema. How the functions are implemented,executed and maintained is ignored by the client. It only knows of theGraphQL endpoint as a factor.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This empowers clients and makes software be driven by client code. Italso improves latency since the program is executed server-side with&lt;em&gt;locality&lt;/em&gt;. And it empowers clients with flexibility insofar theserver can evolve and adapt without clients having to change. &lt;em&gt;End of Aside&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Because we are working with a language, the best way to approach theproblem is to treat it as such. Processing GraphQL requests runs thenormal gauntlet of a interpreter:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Scan incoming byte stream into tokens&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Parse tokens into an abstract syntax tree&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Elaborate the tree and type check it as well&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Execute: use an interpreter to execute the request&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;It is important to stress interpretation is often enough. In a typicalimplementation, the work done in the execution phase is not where timeis spent. Usually, we measure the time in μs for the interpretationstep, whereas reading data is usually more costly in the ms-range. Ifyou have any distributed access in the query, that is going to bewhere time is spent. The only counter-example is when you have alldata in memory on the Erlang node, readily available. In principle,you could pre-compile an execution to Erlang code, and then directlyexecute said code if this proved to be too slow. But we aren’t thereyet in the current implementation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang implementation currently uses interpretation directly onthe AST and doesn’t compile via a Lambda calculus core. This, I think,is mostly a mistake to be fixed at a later point in time.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_type_checking&#34;&gt;Type checking&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In the GraphQL &lt;a href=&#34;https://graphql.github.io/graphql-spec/&#34;&gt;specification&lt;/a&gt;,there are two sections of interest: &lt;em&gt;Type System&lt;/em&gt; and &lt;em&gt;Validation&lt;/em&gt;.Where you &lt;em&gt;can&lt;/em&gt; execute a GraphQL request without worrying about itswell-typedness, it seems rather futile to do so. So we decided to bakethe validation into a proper checking phase in the engine.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In hindsight, we think this has been the correct choice. The languageis quite amenable to a classic operational semantics on its types. Thetransformation into a proper logic uncovered many corner cases in thespecification which needed clarification. Also, we’ve given opinionsfrom time to time on the specification based on what is possible in alogic, and also what is easy to implement in a logic. This helpscoherence of the language quite a bit.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The first type checker we wrote were based on a classic algorithm. Ithad many bugs, mostly because it was built and extended as we wentalong implementing more and more language features. So with thatexperiment behind us, we embarked on the idea to rewrite it using amore modern style, hopefully simplifying and squashing further bugs inthe process. At this point, we had a sizable test suite, so a rewritewould not introduce too many futher faults.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I’m pretty sure bidirectional type checking is part of the folk-lore,but there are some really good expositions on them. One is written byDavid R. Christensen, and another by Frank Pfenning:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://davidchristiansen.dk/tutorials/bidirectional.pdf&#34; class=&#34;bare&#34;&gt;http://davidchristiansen.dk/tutorials/bidirectional.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&#34;https://www.cs.cmu.edu/~fp/courses/15312-f04/handouts/15-bidirectional.pdf&#34; class=&#34;bare&#34;&gt;https://www.cs.cmu.edu/~fp/courses/15312-f04/handouts/15-bidirectional.pdf&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Once you start using this style of type checker, you will want towrite every type checker in this style.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_the_core_idea&#34;&gt;The core idea&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The key observation is that type checking can be split into a coupleof different building blocks. Once these blocks are established, wecan recombine them, as you would in typical algebraic fashion. Thereare obvious similarities to attribute grammars, as we will see.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We split type checking into three building blocks. We annotate eachentry with a &lt;code&gt;+&lt;/code&gt; if they are given (have positive mode in therelation), and &lt;code&gt;-&lt;/code&gt; if they are returned by the algorithm (havenegative mode):&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Synthesis/Inference: &lt;code&gt;G+ |- e+ ⇒ t-&lt;/code&gt; given an environment &lt;code&gt;G&lt;/code&gt; and anexpression &lt;code&gt;e&lt;/code&gt;, we figure out a type for it, &lt;code&gt;t&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Checking: &lt;code&gt;G+ |- e+ ⇐ t+&lt;/code&gt; check that the expression has given type&lt;code&gt;t&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Subsumption: &lt;code&gt;sub t+ s+&lt;/code&gt; check that the type &lt;code&gt;t&lt;/code&gt; is a subtype of&lt;code&gt;s&lt;/code&gt;. That is that &lt;code&gt;t&lt;/code&gt; “fits inside” &lt;code&gt;s&lt;/code&gt; in an obvious fashion.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The reason one wants to split into these building blocks are that thetype checker becomes simpler. You so-to-speak use checking to pushdown information you have into subexpressions, and then use synthesison the way to switch judgement mode and gather knowledge about types.This pendulum of back-and forth between the two building blocks makesa lot of type checking rules simple. The subtype relation is used toverify you don’t break rules along the way.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;Example:&lt;/em&gt; If we have a type which is non-nullable in GraphQL: &lt;code&gt;t!&lt;/code&gt;and we are checking it against a type &lt;code&gt;s&lt;/code&gt; which is nullable. Then thisamounts to ignoring the non-nullability and check &lt;code&gt;t&lt;/code&gt; against &lt;code&gt;s&lt;/code&gt;.This is because a non-nullable value is “stricter” than a nullableone and fits nicely inside it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A typical pendulum operation when checking a request is that of aschema-lookup. To check against a given type we synthesize aschema-lookup, hence obtaining a proper type for the subexpression,which we then proceed to check.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;What is omitted in the above, compared to the real checker, is that wealso &lt;em&gt;elaborate&lt;/em&gt; the AST. We annotate the tree with the types wefound. This eliminates a lot of later hash-table lookups because theneeded type information is already in the tree.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Also, literal values are input-coerced in the type checker. This isdone as a partial execution of the query for the parts which areconstant.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_flow_polarity&#34;&gt;Flow Polarity&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The second observation is that in GraphQL, there are two major flows:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Input: Client → Server (positive flow)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Output: Server → Client (negative flow)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In turn, every GraphQL term is either present in one or both of theseflows. For instance, an &lt;em&gt;input type&lt;/em&gt; has positive flow, whereas anobject type returned has negative flow. There are also nonpolar flowsin scalars and enums.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The flows guide how one should check against types. In the positiveflow direction, we cannot trust the client, but the GraphQL schema onthe server side can be trusted. Hence, we should recurse over the typesof the schema, not what the client provided. This guards against theclient omitting a required argument for instance.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In contrast, the negative flow reverses the recursor: here, we areonly interested in what the client wants, so we only check thosevalues. If the schema/server provides more values but they areillegal, they are ignored since the client did not request them.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Using these observations, it is possible to figure out many questionsone might have when writing the type checker. Most loops writethemselves based on the flow rules. And most checking rules writesthemselves via the three bidirectional building blocks. Theconsequence is a small and lean type checker for GraphQL.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_results&#34;&gt;Results&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_code_size&#34;&gt;Code size&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The approach used here currently amounts to about 1000 LOC, includingcomments. The reference implementation uses around 3500 LOC on thesame thing, also including comments.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In addition, our code reads as typical operational semantics, whichmakes it far easier to validate and verify. Many bugs have been fixedby addition of a simple rule, or rearrangement of the rule checkingorder.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;If one wanted to translate GraphQL type rules into a logical frameworksuch as Twelf, or into a proof assistant such as Agda, it should befairly straightforward. Also, the static semantics in operational formshould be easier to write down if one wanted a more formal approach tothe type checking of GraphQL.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_speed&#34;&gt;Speed&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The type checker usually runs much faster than the interpreter phase.A query is static, and not executed per fetched node, whereas theinterpreter has to walk over data returned. Factors of 1000:1 in favorof the type checker is not unheard of. This argues one should writethe type checker for simplicity rather than speed.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>{&#39;EXIT&#39;, joe, goodbye}</title>
       <link>https://jlouis.github.io/posts/joe-goodbye/</link>
       <pubDate>Sun, 21 Apr 2019 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/joe-goodbye/</guid>
       <description>&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Jesper, I have this idea in which we’ll connect &lt;em&gt;all&lt;/em&gt; of the worldsErlang systems to each other, imagine if every process could talk toevery other process, world-wide!&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div class=&#34;attribution&#34;&gt;— Joe Armstrong&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Joe was never short on ideas when you spoke to him. At conferences, hewould engage people with his newest idea, or he would find peopleacross the room and connect them. This often resulted in newacquaintances, interesting conversations, and new insights. Joe actedas the fountain from which insights sprang. He always had a newproject going, and was keen to tell about it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Joe would speak to everyone. It didn’t matter if they were new to theworld of Erlang, or computers, or if you had 20 years of experience.He would quickly find your level, and then discuss at that level.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In my mind, three rules embodied the ideas of Joe:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;They were always practical and wanted to solve a grand problem withcomputers. Most often, the limitations of physics played a role.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;They always felt a little bit crazy, mainly due to the novelty ofthe idea.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;They were going to restructure your brain, and how you thought aboutstuff.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When I was writing a BitTorrent client for Erlang, Joe was quick tocomment on the code “This part uses defensive code style, you canprobably just let it crash.” It took some years for that lesson tofully sink in, as it did with most of Joes stuff. He would gentlynudge you in a direction, and by following his trajectory, youlanded perfectly.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Most people reading this will know Joe for his work on Erlang. But hehad lots of ideas, and not all of them pertained directly to Erlangitself, though it was often the vehicle. He had a keen interest inmusic and did collaboration on the Sonic Pi with Sam Aaron. Up untilrecently, Joe was working on improving wiki tooling. In particular,he’d realized how he needed a quine,&lt;sup class=&#34;footnote&#34;&gt;[&lt;a id=&#34;_footnoteref_1&#34; class=&#34;footnote&#34; href=&#34;#_footnotedef_1&#34; title=&#34;View footnote.&#34;&gt;1&lt;/a&gt;]&lt;/sup&gt; the wiki should contain its own source codeso it could reproduce itself. This would ensure the longevity of thewiki. This work was in April 2019, so he was working on stuff up untilhis untimely death.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Joe liked to find minimal solutions to problems. He would strip layerupon layer off a problem until he had the core. He created a stack ofuniversal binary formats, UBF. The ingenious part of this was that totransfer a term, one would transfer a &lt;em&gt;program&lt;/em&gt; which when executed ona small stack-based virtual machine would yield said term. And thecommands were chosen from the printable ASCII alphabet.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The higher layers in the stack was the basis for a lot of discussionsI had with Joe. Both of us agreed that what happens “inside” anErlang process wasn’t that interesting in the grand scale of things.It was the communication which was important, and it should have acontract system. Joe had certainly invented most of this before Ieven started looking at Erlang as a language. And I still—​to thisday—​believe that this is future of protocol communication.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;To see how visionary Joe was, his idea was to use such a contractsystem to get any Erlang process on any node to talk to another Erlangprocess, somewhere out in the universe. Essentially, this gives you“Serverless” operation, so he was a couple of years ahead of thepack on that.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Joe also wanted to mix this with a content addressable storagespanning the internet. He would speak fondly of IPFS which to a largeextent was this vision. The main idea is to generate the reference keyfor data from the data itself, usually a cryptographic hash over thedata. This in turn provides integrity: if the data changes, so doesits key. Now, if you refer to data by its key, then you can verify yougot the right data. Joe wanted to use this as a basis for software:“I can send you the hash, and you can fetch the library if you don’thave it.” he told me. He also wanted to use this idea to protect oldsoftware so “It could still run after many years.”--another reasonJoe preferred minimalistic approaches to software. “You see, apackage version is the hash of its source code, not a version number,that would be silly.”&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;He was adamant on making computers useful.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The greatest brain restructure, however, was always in the idea thatyour abstract logic of a program &lt;em&gt;has&lt;/em&gt; to execute in the physicalenvironment. This meant coping with failure when it happened as theonly way to build robust software. Programming without this profoundinsight—​software cannot proactively remove all error—​is as silly asit is dangerous in hindsight.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Once you embrace fault tolerance, then you have the feeling of a burdenreleased, and programs gets far easier to write. Of course, the moreseasoned programmer knows when you can be proactive and when you haveto be reactive. But if there one thought which has shaped the way Ithink about programming the most, it is this.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The second greatest brain restructure was Joe’s dismissal ofperformance in software. In a post to the Erlang mailing list, Joewould come up with the following table:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre&gt;This is what we do: (We = ///)    1) hack it in erlang    2) fast enough - ship it    3) tweak the erlang    4) fast enough? - ship it    5) hack it in C?    6) fast enough - ship it    7) tweak the C    8) fast enough? - ship it    9) make an FPGA    10) fast enough - ship it    11) make an ASIC    12) fast enough - ship itAs you go down this list things cost more and more - step 11 costs1M$/try - to pass step 9you need to have a high volume product (10&amp;#39;s to hundreds of thousands of units)&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The core idea is that if you want to go really fast, you need toimplement hardware specific to the problem, and you can only hope totweak the software so far in performance. And he would make a pointabout setting up a specified target before starting the tweakery, soyou’d know when to stop. Over the years, I’ve veered in the samegeneral direction as Joe.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;One thing I liked about Joe was his fearless approach to computing andto life. He’d never bow to authority. He’d would never be afraid toprovoke if it was necessary. He never ever stopped R&amp;amp;D. He wouldtinker with things until he understood them, then find something newto look at. But only after he told you about his findings. Sharing washis modus operandi.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;At conferences—​in which Joe was an attendant—​there would be thishallway track going on where people would talk with Joe. A slot would beskipped here and there. But some interesting conversation would behad, and people would convene around him in a circle that grew everlarger. I’ve watched more than once when a “innocent bystander” wasdrawn into his web of stories, findings, and insights.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Being a speaker with Joe in the audience was always a blast. Once hesensed he was allowed to interact, you could be sure he would“heckle” your talk in the most awesome way. It only took a smirk andyou saying &lt;code&gt;{hello, joe}&lt;/code&gt; and that would be his cue. We should havemic’ed him up at times.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When he did speak up, he would often frame a question such that it puta speaker in a position where they could really show their work. Neverhave I heard a bad question by Joe.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This was the Joe I knew. I think we owe him a lot with regard topushing software and computer science ahead. The best we can do is tomake sure his grand ideas are not lost upon us, and that they areimplemented in the future to come.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;And then perhaps, we will reach a point where Joe’s prediction fromthis Month will ring true:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;One day computers might become useful.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;div class=&#34;attribution&#34;&gt;— Joe Armstrong&lt;/div&gt;&lt;/div&gt;&lt;div id=&#34;footnotes&#34;&gt;&lt;hr/&gt;&lt;div class=&#34;footnote&#34; id=&#34;_footnotedef_1&#34;&gt;&lt;a href=&#34;#_footnoteref_1&#34;&gt;1&lt;/a&gt;. A quine is a self-reproducing program&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Erlang and code style</title>
       <link>https://jlouis.github.io/posts/erlang-and-code-style/</link>
       <pubDate>Tue, 20 May 2014 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/erlang-and-code-style/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Correct Erlang usage mandates you do not write any kind of defensive code. Thisis called &lt;em&gt;intentional programming&lt;/em&gt;. You write code for the intentional controlflow path which you expect the code to take. And you don’t write any code forthe paths which you think are not possible. Furthermore, you don’t write codefor data flow which was not the intention of the program.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_it_is_an_effectsilly&#34;&gt;It is an effect, silly&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;If an Erlang program goes wrong, it crashes. Say we are opening a file. We can&lt;em&gt;guard&lt;/em&gt; the file open call like so:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;{ok, Fd} = file:open(Filename, [raw, binary, read, read_ahead]),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;What happens if the file doesn’t exist? Well the process crashes. But note wedid not have to write any code for that path. The default in Erlang is to crashwhen a match isn’t valid. We get a badmatch error with a reason as to why wecould not open the file.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A process crashing is not a problem. The program is still operating andsupervision—An important fault-tolerance concept in Erlang—will make sure thatwe try again in a little while. Say we have introduced a race condition on thefile open, by accident. If it happens rarely, the program would still run, evenif the file open fails from time to time.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;You will often see code that looks like:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;ok = foo(...),&amp;lt;br&amp;gt;ok = bar(...),&amp;lt;br&amp;gt;ok = ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;which then asserts that each of these calls went well, making sure code crashesif the control and data flow is not what is expected.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Notice the complete lack of error handling. We don’t write&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;case foo(...) of  ok -&amp;gt; case bar(...) of ... end;  {error, Reason} -&amp;gt; throw({error, Reason})end,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Nor do we fall into the trap of the Go programminglanguage and write:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;res, err := foo(...)if err != nil {  panic(...)}res2, err := bar(...)if err != nil {  panic(...)}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;because this is also plain silly, tedious and cumbersometo write.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The key is that we have a crash-effect in the Erlang interpreter which we caninvoke where the default is to crash the process if something goes wrong. Andhave another process clean up. Good Erlang code abuses this fact as much aspossible.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_intentional&#34;&gt;Intentional?&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note the word intentional. In some cases, we do expect calls to fail. So we justhandle it like everyone else would, but since we can emulate sum-types inErlang, we can do better than languages with no concept of a sum-type:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;case file:open(Filename, [raw, read, binary]) of    {ok, Fd} -&amp;gt; ...;    {error, enoent} -&amp;gt; ...end,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Here we have written down the intention that the file might not exist. However:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;We only worry about non existence.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;We crash on &lt;code&gt;eaccess&lt;/code&gt; which means an access error due to permissions.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Likewise for &lt;code&gt;eisdir&lt;/code&gt;, &lt;code&gt;enotdir&lt;/code&gt;, &lt;code&gt;enospc&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_why&#34;&gt;Why?&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Leaner code, that’s why.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We can skip lots of defensive code which often more than halves the code size ofprojects. There are much less code to maintain so when we refactor, we need tomanipulate less code as well.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Our code is not littered with things having nothing to do with the “normal” codeflow. This makes it far easier to read code and determine what is going on.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang process crashes gives lots of information when something dies. For aproper OTP process, we get the State of the process before it died and whatmessage was sent to it that triggered the crash. A dump of this is enough inabout 50% of all cases and you can reproduce the error just by looking at thecrash dump. In effect, this eliminates a lot of silly logging code.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_data_flow_defensive_programming&#34;&gt;Data flow defensive programming&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Another common way of messing up Erlang programs is to mangle incoming datathrough pattern matching. Stuff like the following:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;convert(I) when is_integer(I) -&amp;gt; I;convert(F) when is_float(F) -&amp;gt; round(F);convert(L) when is_list(L) -&amp;gt; list_to_integer(L).&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The function will convert “anything” to an integer. Thenyou proceed to use it:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;process(Anything) -&amp;gt; I = convert(Anything), ...I...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The problem here is not with the process function, but with the call-sites ofthe process function. Each call-site has a different opinion on what data isbeing passed in this code. This leads to a situation where every subsystemhandles conversions like these.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There are several disguises of this anti-pattern. Here isanother smell:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;convert({X, Y}) -&amp;gt; {X, Y};convert(B) when is_binary(B) -&amp;gt;    [X, Y] = binary:split(B, &amp;lt;&amp;lt;&amp;#34;-&amp;#34;&amp;gt;&amp;gt;),    {X, Y}.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This is stringified programming where all data are pushed into a string and thenmanually deconstructed at each caller. It leads to a lot of ugly code withlittle provision for extension later.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Rather than trying to handle different types, enforce the invariant early on theapi:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;process(I) when is_integer(I) -&amp;gt; ...&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;And then never test for correctness inside your subsystem. The dialyzer is goodat inferring the use of I as an integer. Littering your code with is_integertests is not going to buy you anything. If something is wrong in your subsystem,the code will crash, and you can go handle the error.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There is something to be said about static typing here, which will force you outof this unityped world very easily. In a statically typed language, I couldstill obtain the same thing, but then I would have to define something along thelines of (* Standard ML code follows *)&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;datatype anything = INT of int                  | STRING of string&amp;lt;br&amp;gt;                  | REAL of real&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;and so on. This quickly becomes hard to write pattern matches for, so hencepeople only defines the anything type if they really need it. (Gilad Bracha waspartially right when he identified this as a run-time check on the value, butwhat he omitted was the fact that the programmer has the decision to avoid acostly runtime check all the time—come again, Gilad ☺).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_the_scourge_of_undefined&#34;&gt;The scourge of undefined&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Another important smell is that of the &lt;code&gt;undefined&lt;/code&gt; value. The story here is thatundefined is often used to program a Option/Maybe monad. That is, we have thetype&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;-type option(A) :: undefined | {value, A}.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;(For the static typists out there: Erlang does have a type system based onsuccess types for figuring out errors, and the above is one such typedefinition)&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;It is straightforward to define reflection/reification into an exception-effectfor these. Jakob Sievers&lt;a href=&#34;https://github.com/cannedprimates/stdlib2/blob/master/src/s2_maybe.erl&#34; class=&#34;bare&#34;&gt;https://github.com/cannedprimates/stdlib2/blob/master/src/s2_maybe.erl&lt;/a&gt; stdlib2library already does this, as well as define the monadic helper called do(Though the monad is of the Error-type rather than Option).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But I’ve seen:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;-spec do_x(X) -&amp;gt; ty() | undefined  when X :: undefined | integer().do_x(undefined) -&amp;gt; undefined;do_x(I) -&amp;gt; ...I....&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Which leads to complicated code. You need to be 100% incontrol of what values can fail and what values can not. Constructions like the above silently passes undefined on.This has its uses—but be wary when you see code like this. The &amp;lt;em class=&amp;#34;markup—​em markup—​p-em&amp;#34;&amp;gt;undefined&amp;lt;/em&amp;gt;value is essentially a &amp;lt;em class=&amp;#34;markup—​em markup—​p-em&amp;#34;&amp;gt;NULL&amp;lt;/em&amp;gt;. And those were C.A.R Hoare’s billion dollarmistake.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The problem is that the above code is nullable. The default in Erlang is that you never have NULL-like values.Introducing them again should be used sparingly. You will have to think long and hard because once a value isnullable, it is up to you to check this all the time. This tend to make code convoluted and complicated. It is betterto test such things up front and then leave it out of the main parts of the code base as much as possible.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_open_data_representations&#34;&gt;“Open” data representations&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Whenever you have a data structure, there is a set of modules which knows aboutand operates on that data structure. If there is only a single module, you canemulate a common pattern from Standard ML or OCaml where the concrete datastructure representation is abstract for most of the program and only a singlemodule can operate on the abstract type.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This is not entirely true in Erlang, where anyone can introspect any data. Butkeeping the illusion is handy for maintainability.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The more modules that can manipulate a data structure, the harder it is to alterthat data structure. Consider this when putting a record in a header file. Thereare two levels of possible creeping insanity:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;You put the record definition in a header file in &lt;code&gt;src&lt;/code&gt;. In this case only theapplication itself can see the records, so they don’t leak out.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;You put the record definition in a header file in &lt;code&gt;include&lt;/code&gt;. In this case therecord can leak out of the application and often will.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A good example is the HTTP server cowboy where its request object is manipulatedthrough the cowboy_req module. This means the internal representation can changewhile keeping the rest of the world stable on the module API.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There are cases where it makes sense to export records. But think before doingso. If a record is manipulated by several modules, chances are that you can wina lot by re-thinking the structure of the program.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_the_values_true_and_false_are_of_typeatom&#34;&gt;The values ‘true’ and ‘false’ are of type atom()&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;As a final little nod, I see too much code looking like&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;f(X, Y, true, false, true, true),&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Which is hard to read. Since this is Erlang, you can just use a better name forthe true and false values. Just pick an atom which makes sense and then producethat atom. It also has the advantage to catch more bugs early on if argumentsget swapped by accident. Also note you can bind information to the result, bypassing tuples. There is much to be said about the concept of boolean blindnesswhich in typical programs means to rely too much on boolean() values. Theproblem is that if you get a true say, you don’t know why it was true. You wantevidence as to its truth. And this can be had by passing this evidence in atuple. As an example, we can have a function like this:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;case api:resource_exists(ID) of    true -&amp;gt; Resource = api:fetch_resource(ID), ...;    false -&amp;amp;gt; ...end.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But we could also write it in a more direct style:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;case api:fetch_resource(ID) of    {ok, Resource} -&amp;gt; ...;    not_found -&amp;gt; ...end.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;(Edit: I originally used the function name &lt;code&gt;resource_exists&lt;/code&gt; above but Richard Carlsson correctly points out this isa misleading name. So I changed it to something with a better name)&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;which in the long run is less error prone. We can’t by accident call thefetch_resource call and if we look up the resource, we also get hold of theevidence of what the resource is. If we don’t really want to use the resource,we can just throw it away.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect2&#34;&gt;&lt;h3 id=&#34;_closing_remarks&#34;&gt;Closing remarks&lt;/h3&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Rules of thumb exists to be broken. So once in a while they must be broken.However, I hope you learnt something or had to stop and reflect on something ifyou happened to get here (unless you scrolled past all the interesting stuff).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I am also interested in Pet-peeves of yours, if I am missing some. The way tobecome a better programmer is to study the style of others.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Erlang String Handling</title>
       <link>https://jlouis.github.io/posts/erlang-string-handling/</link>
       <pubDate>Sun, 23 Feb 2014 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/erlang-string-handling/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The cat is out of the bag. Now, since WhatsApp had success using Erlang, morepeople will gravitate toward the platform. One of the common things that willhappen as a result is that people who do not understand the string handlingcapabilities of the Erlang BEAM VM will fail to use it correctly. This costs alot of unneeded clock cycles and this post aims to thwart it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;First of all, since this is rather VM specific, it also applies to Elixir users.The VM basically handles strings the same way, so you should be thinking in thesame general direction as I am doing here, for Erlang. Though Elixir, to thebest of my knowledge, maps its string type onto binaries.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The first thing to understand is that Erlang is a functional language first andforemost. This means, among other things, data will be immutable by constructionand there is no way to circumvent that. It also means certain tricks pertainingto ephermeral mutability is out the window. And it would be outright against thespirit of Erlang to have mutable data in any form.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_when_you_should_avoid_using_erlang_in_the_firstplace&#34;&gt;When you should avoid using Erlang in the first place&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang as a language fares bad at programs where you have a &lt;em&gt;small&lt;/em&gt;computational kernel which &lt;em&gt;has to&lt;/em&gt; be extremely fast. This is the case for alot of heavyweight processing tasks. It is often better to take your kernel andmove it into another language, or in some cases move the kernel onto an FPGA orinto hardware, depending on your needs.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Depending on the problem, it may not be efficient to spend your timeimplementing the code in Erlang. Unless you plan to utilise some of the otherErlang strengths, like robustness, you may be better off by just implementingyour system in Go or Clojure. Alternatively, you can write a NIF and then handlethe core kernel in C. Don’t use Erlang when another tool solves the job in a waybetter and way faster way. A rough estimate is that C code is 20-50 times fasterfor tight computational kernels.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang language is built for handling more complex interactions where theraw execution speed matter less and the program structure matters more. If yoursystem has no specific kernel which is executing for heavyweight processing,then Erlang might suit your needs. If your system is bound to memory or I/O thenErlang may be &lt;em&gt;very&lt;/em&gt; suitable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;You goal is to get most processing out of the emulator loop and onto the BEAM VMcore. The runtime core is very efficient at handling large amounts of data andmany structures are built such that they can sustain heavy load. A good way tolook at this is with the linux perf(1) tool. Run perf on the beam.smp emulatorand if &lt;code&gt;beam_emu.c&lt;/code&gt; is spending too much time, chances are you are processingheavy. Even processing-heavy applications I have written tend to have 20% timespent in the emulator loop. The consequence is you can’t win much by replacingthe interpreter with a JIT or a native code compiler. You can only, at best,squeeze the 20% so it is limited how much faster you can get the code by doingthis.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Aside: A JIT would still be useful so more of the Erlang system could be writtenin Erlang rather than C. But for most code, it is not given a priori it wouldyield a speedup.&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_what_is_a_string&#34;&gt;What is a string()?&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang string type is implemented as a single-linked-list of unicode codepoints. That is, if we write “Hello” in the language, this is represented as&lt;code&gt;[$H, $e, $l, $l, $o]&lt;/code&gt;. The overhead of this representation is massive. EachCons-cell use 8 bytes for the code point and 8 bytes for the pointer to the nextvalue. This means that the 5-byte ASCII-representation of “Hello” is 5*16 = 80bytes in the Erlang representation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Strings are shared. If we write &lt;code&gt;L = &amp;#34;World&amp;#34;,&lt;/code&gt; followed by &lt;code&gt;A = &amp;#34;Hello&amp;#34; ++ L&lt;/code&gt;,then A and L shares the tail, due to persistence and immutability. In some casesthis can be utilised to limit the amount of data present in a system, andsomewhat help with the massive data blowup you will otherwise see.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang is not unique in having the string-as-integer-list representation. It isthe same representation which is used by Haskell. But since no type informationis present, you can’t discriminate between a list of integers and a string. Youwill have to know from the code at hand.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There are a lot of disadvantages of this representation. It results in memoryblowup, more cache misses, more data bandwidth use, and so on. On the otherhand, all the normal list-processing functions are present and can be used onstrings alike. So to manipulate strings, you have access to four modules:&lt;code&gt;[string, lists, unicode, re]&lt;/code&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The module &lt;code&gt;string&lt;/code&gt; contains valuable helper functions for manipulation of strings. Most importantly:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;dlist&#34;&gt;&lt;dl&gt;&lt;dt class=&#34;hdlist1&#34;&gt;&lt;code&gt;string:tokens/2&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;which can be used to split a string into parts, and&lt;/p&gt;&lt;/dd&gt;&lt;dt class=&#34;hdlist1&#34;&gt;&lt;code&gt;string:join/2&lt;/code&gt;&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;which can join strings together with a separator.&lt;/p&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I normally only use plain strings like these when the data sizes are rathersmall and we are not on a critical code path. Otherwise, you need to dosomething else in order to make things work quickly and efficiently.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The &lt;code&gt;lists&lt;/code&gt; module contains many functions which are useful for working withstrings. As an example, &lt;code&gt;lists:prefix/2&lt;/code&gt; can be used on strings as well.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The &lt;code&gt;re&lt;/code&gt; module implements regular expressions. Here is thebasic rule:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Do NOT use the &lt;code&gt;re&lt;/code&gt; module&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Usually, there are better ways to handle data than to supply a regularexpression to handle it. Mind you, I utterly love using regexes in editors and Ialso like using them in lexers. But for most normal data processing, regularexpressions are overkill. Also, the regular expression engine in Erlang has beenaltered so it preempts. This avoids a long-running regex to destroy the VM’sscheduling mechanism.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Typical code will have maybe one or two calls to the &lt;code&gt;re&lt;/code&gt; module per 5000 linesof code. If you have more than that, chances are you are trying to program PERLin Erlang. And that is a bad idea.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;However, the &lt;code&gt;re&lt;/code&gt; module is way faster than the older &lt;code&gt;regexp&lt;/code&gt; module which was deprecated.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_the_binarytype&#34;&gt;The binary() type&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang, like Haskell, saw the problem with a memory-heavy string type. So theyboth implement a type which is more efficient at handling large amounts of data.In Erlang, this is called a &lt;code&gt;binary&lt;/code&gt; and in Haskell it is called a &lt;code&gt;ByteString&lt;/code&gt;.Binaries are arrays of binary data. They are immutable, which means they can beshared. Also, referral to subparts of a binary can be shared by having thesystem store 3 values called a sub-binary:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;A pointer to the original binary&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;An offset&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A size&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note that sub-binaries work a bit like Go’s slice construction in this way. TheVM is built such that passing around binaries and subbinaries are alwaysefficient. The trick is immutability, which allows the system to pass pointerson binaries rather than passing the binary value itself.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Binaries, like in Go, also has extra &lt;em&gt;capacity&lt;/em&gt; in the sense that in some casesa binary can be appended to efficiently without having to copy the binary datato a new place. The system will automatically extend binaries with extracapacity when they are copied, ensuring efficient append.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When programming Erlang, the compiler and VM will automatically generatebinaries and sub-binaries for you. Write your code in a straightforward andreadable manner first. Then compile your program with &lt;code&gt;+bin_opt_info&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;to have the compiler report on which binaries were not optimised in code whichis heavily traversed by the program.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Binaries can be pattern matched. This is extremely efficient, but sometimes youcan’t write a matching rule since they essentially work from the beginningalways. You can’t “search” in a binary until you hit something which matches bya single pattern match. The way to handle this problem is by using the &lt;code&gt;binary&lt;/code&gt;module:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;binary:split/3&lt;/code&gt; is extremely powerful. It is the binary variant of&lt;code&gt;string:tokens/2&lt;/code&gt; but it is returning shared data and so does only produce asmall amount of garbage. The split string simply refers into the original binarythrough sub-binaries. Be very aware of the option “[global]” which will allowyou to split the binary into more than two parts.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;binary:match/3&lt;/code&gt; is your generic search routine for picking out parts deeply in binary data.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;binary:compile_pattern/1&lt;/code&gt; allows you to build some simple compiled patterns like a weaker(but way faster) regular expression search&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;binary:copy/1&lt;/code&gt; forces a copy of a binary. This is useful if you have a 1 megabyte binary andyou have found a 45 byte sequence in it—and you only want that sequence. Then you can copythe sequence which means you don’t hold on to the 1 megabyte binary anymore—in turn allowingthe garbage collector to collect it. This is extremely useful if you are cutting input intopieces (with &lt;code&gt;split/3&lt;/code&gt;) and storing it at rest for a long time. For instance in ETS.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_the_iodata_type&#34;&gt;The iodata() type&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There is another quite important data type which I want to describe. These arecalled &lt;code&gt;iodata()&lt;/code&gt; or &lt;code&gt;iolists()&lt;/code&gt;. The rule is the following:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;A list of integers in the range 0..255 is IOData.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A binary is IOData.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Lists of IOData is IOData.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In particular, this means you can form IOData by collecting IOData as lists.This means string concatenation in the language is O(1). &lt;code&gt;p(IOData) → [&amp;#34;&amp;lt;p&amp;gt;&amp;#34;, IOData, &amp;#34;&amp;lt;/p&amp;gt;&amp;#34;].&lt;/code&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The &lt;code&gt;p/1&lt;/code&gt; function given here will wrap IOData in a standard paragraph sectionin HTML, but it will not reallocate any data, nor will it generate any garbage.The sections “&amp;lt;p&amp;gt;” and “&amp;lt;/p&amp;gt;” are constants, so the only allocation that willhappen will be for the front of the list, two list elements.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Most IO functions in Erlang understands IOData directly. This means you canavoid having to flatten data, but just send the IOData out over a socket or thelike. It avoids costly allocations and copies on the IO pipe in your program.Highly recommended!&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A good way to gauge how well thought out a library is is to look at how well ithandles IOData. If it doesn’t and requires you to explicitly call&lt;code&gt;iolist_to_binary/1&lt;/code&gt; then chances are the library is not that well written.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_handling_unicode_data&#34;&gt;Handling &lt;code&gt;unicode()&lt;/code&gt; data&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Unicode data in Erlang is handled by the &lt;code&gt;unicode&lt;/code&gt; module, which can convert betweenrepresentations of Unicode. My recommendation however, would be to keep most unicode data as UTF-8 stringsin binaries. You can match on unicode code-points:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;-module(z).-export([len/1]).len(B) when is_binary(B) -&amp;gt;len(B, 0);len(&amp;lt;&amp;lt;&amp;gt;&amp;gt;, K) -&amp;gt; K;len(&amp;lt;&amp;lt;_ /utf8, Rest/binary&amp;gt;&amp;gt;, K) -&amp;gt; len(Rest, K+1).&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This is useful together with the ability to input character strings as UTF-8:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;listingblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre class=&#34;highlight&#34;&gt;&lt;code&gt;Erlang R16B03-1 (erts-5.10.4) [source-ce3d6e8] [64-bit] [smp:8:8] [async-threads:10] [hipe] [kernel-poll:false][dtrace]Eshell V5.10.4 (abort with ^G)...2&amp;gt; z:len(&amp;lt;&amp;lt;”Rødgrød med fløde”/utf8&amp;gt;&amp;gt;).173&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In Release 17.0, the default will be UTF-8 in Erlang files. This will probablyhave some deep effects on Erlang source code, but it will ultimately helpgetting Unicode into Erlang. Release 18.0 is planned to accept unicode atoms aswell, to open up the design space.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_attack_vectors&#34;&gt;Attack Vectors&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The basic rule of all Erlang string handling is this:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Never never NEVER work on stringly typed data&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When data is “stringly” typed, it means that your data has no structure andeverything are represented in strings. This is fairly expensive to work on for asystem since you are limited to use the string-handling code. Parsing is alwaysexpensive and this hurts your processing speed. Some languagues, like awk orperl are built to process these kind of things. But you rather do not want to dothis processing in Erlang.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The way you avoid stringly typed data is to take the input and transform it asearly as possible into structured data inside your code. That way, you can avoidworking on the string data, and you only need it in a few places. The morestructure you can attach to the data, the better.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The primary problem is when you have to work with a bad data format. Again, thetrick is to turn the bad format into something sensible quickly and then processit as sensible data.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang is designed to work with data that has structure. With structure, you canpattern match which is fast. Without structure, you have to rely on standardtechniques and this is almost always going to be a pain in the language. Sodon’t do it. Convert data into a structured format and then proceed by handlingthe structure with pattern matches.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_immutability&#34;&gt;Immutability&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang takes a stance. All data are immutable. In particular, strings areimmutable. Binaries are immutable. There will be an overhead to this stance. Ifyou can’t accept this, you must pick another language. That said, the advantagesof immutability far outshine the benefits of immutability.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang is immutable because it eliminates a large source of programming errorsand programming mistakes. After all, the value of an incorrect program is lowerthan a correct one. This stance is highly unlikely to be changed, since thesafety guarantee provided by immutability is part of the Erlang-DNA.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_when_you_have_control_of_data&#34;&gt;When you have control of data&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In some situations you control the format of the data you are going to use. Thisis an &amp;lt;em class=&amp;#34;markup—​em markup—​p-em&amp;#34;&amp;gt;excellent&amp;lt;/em&amp;gt; oppurtunity to picksome clever ways of working with data. In particular to enforce structure ondata by default. If communicating between Erlang systems, you can use&lt;code&gt;term_to_binary/1&lt;/code&gt; &amp;amp; &lt;code&gt;binary_to_term/2&lt;/code&gt; and just put data at rest in thestandard Erlang-format. If the foreign system also supports this format, it isan excellent way to interchange data. The encoder/decoder for this format iswritten in C and it also handles very large terms with grace—the running processwill be preempted while producing the binary.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The man page for &lt;code&gt;inet&lt;/code&gt;, &lt;code&gt;erl -man inet / setopts\( RET&lt;/code&gt; describes common socketoptions you can set on a socket. By setting the &lt;code&gt;packet&lt;/code&gt; option you can controlhow the system decodes inbound data. Most interesting, you can set ASN.1 BERencoding or Line-wise encoding. If you value speed, you should consider anefficient binary format.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_json&#34;&gt;JSON&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The ubiquitous format today, you need to handleis JSON data. I don’t particularly like JSON as a data exchange format, since it is very weak in whattypes it encodes. I’d much rather have a format like Joe Armstrong’s UBF or the Clojure &lt;code&gt;edn&lt;/code&gt; &amp;amp; &lt;code&gt;data.fressian&lt;/code&gt; encodings. But JSON it is. There are two good JSON libraries for Erlang:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;dlist&#34;&gt;&lt;dl&gt;&lt;dt class=&#34;hdlist1&#34;&gt;jsx &lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;a href=&#34;http://github.com/talentdeficit/jsx&#34; class=&#34;bare&#34;&gt;http://github.com/talentdeficit/jsx&lt;/a&gt;&lt;/p&gt;&lt;/dd&gt;&lt;dt class=&#34;hdlist1&#34;&gt;jiffy&lt;/dt&gt;&lt;dd&gt;&lt;p&gt;&lt;a href=&#34;http://github.com/davisp/jiffy&#34; class=&#34;bare&#34;&gt;http://github.com/davisp/jiffy&lt;/a&gt;&lt;/p&gt;&lt;/dd&gt;&lt;/dl&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;They differ in how they are implemented. The jsx library is implemented in pureErlang and is the slower of the two. The jiffy library uses a C NIF (NativelyImplemented Function) to run the encoder and decoder and is about 10 timesfaster.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Beware: the jiffy library can’t be used to decode large JSON data sets. Thedecoder is not a well-behaved NIF and as such it can mess up the schedulers ifit is used to decode large data strings. If the JSON takes more than 1ms todecode, you should probably avoid using it. In Release 17.0, we get so-called&lt;em&gt;dirty schedulers&lt;/em&gt; which can be used to work around this problem.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The other problem with JSON data is the internalErlang representation. Right now, there is no isomorphic mapping for JSON objects/dictionaries intoErlang. This will be fixed in Release 17.0 as well, since it includes maps soyou can obtain a native mapping of objects/dictionariesinto Erlang data. I also have a side project on the run to properly handle JSON to Record encoding inErlang, but this still ongoing work. And it will take some time before it is fully implemented.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;On the other hand, note that JSON will never be a fast interchange format. Ifyou use JSON to move large amounts of data, you are screwed. Plain and simple.You best bet is then to hope data are sent as many small pieces so you can usejiffy on them. Or wait till 17.0 so you can get jiffy in a dirty-schedulervariant.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_files&#34;&gt;Files&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;You should study the section “PERFORMANCE” of the man page &lt;code&gt;erl -man file&lt;/code&gt; Notethat in order to have fast file I/O you need to open the file in “raw” mode, usebinaries, and you can usually also benefit by following some of the advice inthe section about performance. The general rule of IOData applies: If you supplyIOData, the underlying file driver is able to map this onto a unix &lt;code&gt;pwrite(2)`&lt;/code&gt;call which is highly efficient.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Not opening in raw mode does have its benefitsthough, because you can then get the IO subsystem to work. This subsystem allow you to open a file on aforeign file system (on another node) and then operate on that file. If you don’t need the high speed,this is desirable in many situations, should your system span multiple nodes.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_closing_off&#34;&gt;Closing off&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;It is a myth erlang strings are slow. You will have to think a bit moreabout what you do in order for the system to speed up. But chances are that string processing won’t beyour limit. It is much more conceivable your bottleneck will have to do with a lock, or the wrongstructure of processes than it will be slow strings.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Error Kernels</title>
       <link>https://jlouis.github.io/posts/error-kernels/</link>
       <pubDate>Fri, 14 Feb 2014 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/error-kernels/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In any computer system, we can split the system into the part which must be correct—no matter what happens; and the part where we don’t need the system to be correct all the time.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A typical example of this is the operating system kernel. We believe the operating system kernel to be correct, but we don’t &lt;em&gt;a priori&lt;/em&gt; trust the userland applications. If one of those fails, the kernel can take over, reap the process by killing it and reclaim the resources the process used. The reason for this is memory protection and the fact that the kernel controls the memory space.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;For programs, there is often a similar piece of the system which has to be correct at all times. But there are also computations we don’t care about. The only thing we care about is that if the system transitions from a state S1 and reaches a state S2, then this new state is consistent. And if we fail in between the transition, we can clean up by removing the failing computation from the system.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Smart programmers will identify the &lt;em&gt;Error Kernel&lt;/em&gt; of their computer system. This is the part of the code base which MUST not fail in any way. And then they will seek to make that kernel as small as possible. This corresponds to the concept of limiting the trusted computer base of a system.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Once you have identified the Error Kernel, you can design your system in a way such that you protect this part of the system the most. If you do it correctly, you should have very few lines of code which needs uttermost correctness. And better yet, you can often keep performance critical and complex code outside of the kernel.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In most languages, the way to control the Error Kernel is by the use of an exception. The idea is that code proceeds along a given path. If something goes wrong along that path, then the code raises an exception which is then handled elsewhere to clean up afterwards.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The key in exception handling code is that you must foresee the possibility of an error. Some languages used checked exceptions in order to force you to handle all possible exceptions. Others use the type system by turning the effect into a monad and then force handling through the type system. And yet others rely on the concept of human oversight to make sure that all exceptional paths are handled correctly.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang uses a different mechanism—albeit it is slightly related to the exception mechanism of most languages. In Erlang, an error crashes the process. And you let another process handle the error. Done correctly, this has a number of interesting consequences:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Your program will automatically have stop-gap measures which limits faults whenever you have a concurrent activity. And you can use processes to build compartments which encapsulate error in the system. The key tools here are persistence and isolation of individual Erlang processes.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Even if you forgot to handle error in an individual process, you can use the default stance to protect the system from total failure. This is the primary reason as to why Erlang copes well with unforeseen errors in the system.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;You can omit writing &lt;em&gt;defensive code&lt;/em&gt; in a lot of places. Any process which operates outside the error kernel does not need to protect itself by being defensive. This does not remove the need to check that operations succeed, but it removes the code path that tries to cope with the error locally. Rather, if something goes wrong, you “nuke it from orbit” and start all over again later or with a different premise.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The notion of the &lt;em&gt;Error Kernel&lt;/em&gt; is not confined to Erlang. It persists in any program you will write. Thinking about it tend to yield more robust system designs, and I encourage any programmer to identify it for their programs.&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>A moonpig-like system</title>
       <link>https://jlouis.github.io/posts/a-moonpig-like-system/</link>
       <pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/a-moonpig-like-system/</guid>
       <description>&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Raven that used to sing—​and other stories&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Mark Jason Dominus wrote about &lt;code&gt;&amp;#34;Moonpig&amp;#34;&lt;/code&gt;, which is his and Rik Signeswork on building a billing system in Perl. He wrote up his story over onhis &lt;a href=&#34;http://blog.plover.com/prog/Moonpig.html&#34;&gt;blog&lt;/a&gt;. At&lt;a href=&#34;http://www.issuu.com/&#34;&gt;Issuu&lt;/a&gt;, Francesco Zanitti, Anders Fugmann,and I wrote a system which has some similarities to Moonpig. This is ahash through that system. Currently, we mostly handle post-paidservices.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Billing mostly sucks. It is one of those areas of software where therealities of the world clashes with your nice logically structured codebase. This clash often produces problematic complications in systems forone reason or the other. Furthermore, to rub salt into the wound, mostbilling solutions out there sucks even more. So we decided, like Markand Rik, to write our own.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In hindsight, there are things we should probably have done differentlyin the structure of the system. And there are things we should perhapshave treated in other ways. But the system is in production and runs. Itrarely gets updates.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_inspiration&#34;&gt;Inspiration&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When we wrote the system, two papers inspired us.&lt;a href=&#34;http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm&#34;&gt;ComposingContracts&lt;/a&gt; by Peyton Jones, Seward and Eber describes a small contractlanguage for financial transactions. And this language is compiled withseveral compilers to produce different interpretations of the samesyntax.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The other source of inspiration was the 3gERP project at&lt;a href=&#34;http://www.diku.dk/&#34;&gt;DIKU&lt;/a&gt; lead by Fritz Henglein. Of interest is&lt;a href=&#34;http://www.diku.dk/~hvitved/&#34;&gt;Tom Hvitved&lt;/a&gt;&amp;#39;s Phd dissertation,which describes an ERP system based on &lt;em&gt;contracts&lt;/em&gt; and &lt;em&gt;eventlogs&lt;/em&gt;. Roughly the idea is that events in the system is sent to apersistent log which is never deleted. Code in contracts read eventsfrom the log and proceed to execute. A central aspect is the concept of&lt;em&gt;replay&lt;/em&gt; where a contracts state can be replayed from the start oftime. This provides Point-in-time-recovery (PITR) of any contract at anypoint, as well as an audit log. Current contract state is kept&lt;em&gt;in-memory&lt;/em&gt; and is never persisted. Only the events that will leadto that state.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Our system—​and the 3gERP model—​consist of contract processes andagent processes. A contract poses &lt;em&gt;obligations&lt;/em&gt; which are read byagents. Once agents fulfill the obligation they send back&lt;em&gt;transactions&lt;/em&gt; to the event log—​and transactions are subsequentlypicked up by the contracts. A powerful concept in the model is that of&lt;em&gt;blame.&lt;/em&gt; If we can’t proceed in a contract due to a time constraintbeing hit, we can see which party had the obligation of an action. Thismeans we can identify if it is the customer or the company which madethe error, and handle it accordingly.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Since our system is written in Erlang, agents are separate(Erlang-)process groups. This allows our system to handle eventsconcurrently, and allows multiple subsystems to proceed. We can alsoreplace standard contracts and agents with mock variants for testing.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Currently we handle all contracts in a single Erlang-process, but thisis clearly a design mistake. We could get better isolation properties bysplitting each contract into a process of its own and then let contractsrun in a truly concurrent fashion.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Another mistake is that we route obligations and transactions over&lt;em&gt;buses&lt;/em&gt; inside the system. But it would probably have been betterto make contracts to direct-calls through a routing/proxy layer to atarget process. The current bus-model is not very Erlang-idiomatic.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_the_key_observations_aboutbilling&#34;&gt;The key observations about~billing&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Here is the primary key observation about billing:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Profit scales proportionally with the billing system load&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Modern computers are incredibly beefy. We can run a gigantic billingsystem in memory on a 7.5 or 15 Gigabyte instance on Amazon EC2. Even ifwe outscale it and need a 244 Gigabyte machine at almost \$7 per hour,chances are our profits are such that this amount of money is peanuts.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Hence, worrying about system performance is—​for most companies—​goingto be premature optimization. Much more important is correctness,durability and resilience. Thus, the focus should be on that and not&lt;em&gt;lolspeed&lt;/em&gt;. This is a welcome change of pace.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This key principle is an efficient driving force behind designdecisions. You can opt for the simple and verifiable algorithms and datastructures over the fast ones. If you ever need to go back and tune thesystem for scale, you will be making so high a profit it will be aproblem of luxury.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Some napkin math: A typical customer account runs a single contract. Acontract is around 2 Kilobytes of memory in Erlang. I have 244 Gigabytesof memory. We will run out around 128 million paying customers. Assumeprofits of $1 per customer and this is not a problem.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The second key observation is this:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We can arrange the system such that we take all the blame for errors&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;That is, whenever we are in doubt, we give the benefit to the customer.Mark wrote about this when he decided to handle rounding errors bygiving customers the fraction which cannot be divided.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But there are many places where this principle can be used to simplifythe code base. If a given feature costs $30,000 to implement but onlyyields you $50 a year, then the effort of implementation is clearly notworth it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This principle gives us more freedom and flexibility in theimplementation because we can handle certain problematic areas by justignoring them while measuring their impact.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Finally:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;quoteblock&#34;&gt;&lt;blockquote&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The world is not perfect and faults will happen&lt;/p&gt;&lt;/div&gt;&lt;/blockquote&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Our system is systematically built to acknowledge certain subsystemswill fail. And the approach is to regard that we are always in a statewhere the subsystem failed. More on that later.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_storage&#34;&gt;Storage&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We store all data in a flat file on disk. Data are stored as Erlangterms in a pseudo-human-readable format (think XML, S-expressions orJSON). This is deliberate. It is much easier to read and verify.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The &lt;em&gt;current&lt;/em&gt; state is handled by a built-in database in Erlangcalled &lt;em&gt;mnesia&lt;/em&gt;. This database stores an in-memory current view.Provides a transactional store loced to the on-disk log and so on. Itprovides a cache of what is in the flat file on disk. We can alwaysthrow away the database and replay the log from the dawn of time (whichis somewhere around Nov. 2011 for this system). In principle Mnesia canalso bootstrap the system faster since we can skip over large parts ofthe log, but we have not had the reason to implement that optimizationyet. A reboot just replays from the start.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Mnesia part also explains how we can do reporting. We have adatabase, almost Relational in nature, which we can query to extractreports. The PITR-property of the event log also lets us answerquestions back in time. But for simplicity, we just store all datapersistently in Mnesia in classic OLTP-manner.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_other_storage_options&#34;&gt;Other storage-options&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;One option we have thought of is to keep a flat file per contract andone global file. The advantage is we can then boot contracts on demandwhen we need them. The disadvantage is we loose an important property ofthe current system: linear time ordering.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The current system forces an ordering on all events and only forwardsevents in that order. This simplifies almost all of the code base.Distribution afficianados might claim that this will be a problem forperformance. But due to the primary key observation, we can ignore it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The other option is to introduce a database to run the event log.Postgres is an obvious candidate. We have not given this much thought,but it may be an option and simplify some parts of the system.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_handling_time&#34;&gt;Handling time&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Time in our system is handled roughly like time is handled in Moonpig.Time is &lt;em&gt;injected&lt;/em&gt; or &lt;em&gt;pushed&lt;/em&gt; into the system. It is neverpulled by the system. Whenever an event happens, there is a timeparameter which is sent into the system and tells us what time it is.Functions inside the system pass on the &lt;code&gt;&amp;#34;current time&amp;#34;&lt;/code&gt; and we nevercall &lt;code&gt;erlang:now()&lt;/code&gt; nor &lt;code&gt;os:timestamp()&lt;/code&gt; inside the codebase.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The consequence is that testing is now suddenly possible. We can quicklyplay out scenarios where time is forwarded a couple of years. The testsystem controls the time fully, so it is easy to play outwhat-would-have-happened scenarios.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When running normally, we inject time at the boundary of the system whensome event happens. In effect, other users do not have to cope with thefact that time is injected into the model. But from a testingperspective, we can just pick the variant of the call where time can beoverridden.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_current_time_contract_time&#34;&gt;Current time &amp;amp; contract-time&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A distinction from Moonpig is how we handle time in contracts. InMoonpig, time is handled by heartbeats and it is the responsibility ofsubsystems to ignore heartbeats which were duplicated etc.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In our system, contracts have an internal time which we can call &lt;code&gt;C&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt;denotes current time, we always have the property that &lt;code&gt;C &amp;lt; T&lt;/code&gt;.That is, the contracts time is always behind the current time by somesmall epsilon value. The scheme where the contract always lags behindreal time allows us to handle heartbeats in a slightly different manner.When an event is injected into the contract, a timestamp T is also sent.The contract now &lt;em&gt;forwards&lt;/em&gt; itself to the next point in time wheresomething interesting happens on the contract. This makes sure duplicateinjections of time and events are ignored by the contract.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This model also describes how we handle problems where the system fails.We have backup procedures. We can just restart the system a couple ofdays later, and it will forward time and do things correctly. Ifanything important should have happened on the days in between, theywill be handled at this point.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note the implication: our system is always in a catch-up mode. It alwaysthinks the state of affairs is that it is behind and need to dosomething to catch up to the current situation.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_quickcheck&#34;&gt;QuickCheck&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We never got around to do QuickCheck models for contracts, but there isan interesting property of contracts which is worth mentioning: Acontracts state is derivable from a stream of transactions. Such acontract should be indifferent to heartbeat-events and other eventstypes that happens in between the transactions. This can beprobalisitically verified by an &lt;a href=&#34;http://quviq.com/&#34;&gt;ErlangQuickCheck model&lt;/a&gt;. But we did not get to do that.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_idempotence&#34;&gt;Idempotence&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A very important aspect of our system is idempotent &lt;code&gt;&amp;#34;best effort&amp;#34;&lt;/code&gt;delivery. When contracts want to have something done, they send out an&lt;em&gt;obligation.&lt;/em&gt; These are picked up by agents and then handled.Obligations may get lost. They are periodically restated by thecontract. If an Agent crashes, it doesn’t matter that it did not handleall the obligations. We will catch up eventually.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Agents track which obligations they have already fulfilled. If so, theyidempotently produce the same answer as before as a &lt;em&gt;transaction&lt;/em&gt;which is then sent back to the contract. Thus, if our event log systemcrashes, the agent can just send in the transaction again.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Charging works on this system as well. A charge contains a uniquereference and it handles transactions idempotently. So it doesn’t matterif the charging system sits in the other end of the world and we losethe network connection. We will just retry the charge with the samereference. Since our end handles the unique reference persistenly ondisk, we can’t generate another reference for the charge. And the otherend can safely store a transaction in their database.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Many areas can be handled with a fire-and-forget type of message. Weonly try to send mails once. If the underlying system accepts the mail,we idempotently mark it as &lt;code&gt;&amp;#34;done and sent&amp;#34;&lt;/code&gt;. This minimizes annoyanceson customers, should we have to try to resend mails.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note that each agent is usually very simple. Often they are less than 40lines of code. And they can be checked individually, without the rest ofthe system.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We only have to worry about progress, but that can be measured. Oursystem extensively uses the&lt;a href=&#34;http://github.com/boundary/folsom&#34;&gt;folsom&lt;/a&gt; system in Erlang totrack counters and gauges so we can see what is happening inside thenode. In fact, we track almost everything with probes in the system.Full instrumentation is something we strongly believe in for every newsystem written.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_immutability&#34;&gt;Immutability&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Like in Moonpig, we use immutable constructions all over the place. Wenever throw away data, but record it into the global event log forfuture replayability. This is also what we use when something goes wrongand we need to figure out what went wrong.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Immutability is also very powerful when one considers debugging. Sincewe have every transition recorded and full PITR-support, we canessentially always rerun the business rules of a contract and see whatwent on inside it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Replayability has an interesting impact. When we upgrade our code innon-compatible ways, we also have to mention that upgrade in the eventlog. So old versions of the code still lives on, but is only used uptill a point. Then it is switched with new versions of the code base.Essentially the system switches between different contract versions overtime.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_floats_time_zones&#34;&gt;Floats / Time zones&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;No floats! Only integers. The system stores everything in centsinternally, but doesn’t do financial calculations. Our plan—​should weneed to do so—​was to store everything in picodollars and calculateexchange rates for other currencies. Much like all time is in UTC andare offset from there at the boundary.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;However, we do note that our billing provider expects floats, we have aboundary conversion going on…​ The mind baffles at times at thechoices made in software systems.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_what_we_skipped_on&#34;&gt;What we skipped on&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We did not implement a DSL for writing contracts. Rather, we wrote thefew contracts we needed in (purely) functional Erlang code.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We don’t have a lot of code in place to manage blame. This is due to thecontract simplicity currently in place. We don’t really need this.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;We could probably improve the model if we had to do it over. I believethis is &lt;em&gt;the&lt;/em&gt; way to do billing systems for the vast majority ofcompanies out there. The code is neat and modularized into contracts,agents and persisters of data. Each can be implemented with a naturalbacking into Erlang processes, proxies for foreign subsystems andRDBMs systems and so on. I also note that a system like&lt;a href=&#34;http://www.datomic.com/&#34;&gt;Datomic&lt;/a&gt; would be near-perfect to store thetransaction log. And would have a nice scalability curve to boot.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The choice of Erlang is rather nice for a system like this, wherecontracts, agents and so on can be modeled as processes. Other goodlanguages could be OCaml—​for its expressive type system, or Go—​forthe goroutines.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>The Erlang Shell</title>
       <link>https://jlouis.github.io/posts/the-erlang-shell/</link>
       <pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/the-erlang-shell/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;(Front Line Assembly: Civilization, Eastern Sun: In Emptiness)&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;As an Erlang programmer I often claim that “You can’t pick parts ofErlang and then claim you have the same functionality. It all comestogether as a whole”. This is true for many programming environmentswhere the main components are built to be orthogonal from each other andthe parts form the cohesive whole. A good example of this approach wouldbe Go as well.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A compelling way of deploying software is what supposedly originatedwith FLEX (Alan Kay). The program, the system and its data are all keptinside an &lt;em&gt;image&lt;/em&gt; which can be persisted to disk and restarted later. Inessence we specify which world we operate in by giving an image. ManySmalltalk systems utilize this notion of images. So do Common Lispsystems. And they even understand how to reconnect to networks andreopen files.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang provides its own, weaker, mechanism for assembling softwarecalled a &lt;em&gt;release&lt;/em&gt;. A release consists of the runtime together with aset of Erlang applications. They are started as a whole—in a specificorder. The same release is usually booted across several machines if wewant to have resilience against hardware faults. The big shift comparedto images is that there are no on-disk persistence. The ideology isdifferent: the system should never stop, so even if one &lt;em&gt;node()&lt;/em&gt; in thecluster is stopped, the data is on other nodes as well and lives. Erlangsystems also allow for seamless upgrades from one release to anotherwhile they are running.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But there are some resemblance from Common Lisp / Smalltalk images andErlang releases. While they don’t persist the data, Erlang images dodefine a separate enclosed system with no link to the original system.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The strength of these persistent models come apparent late in thedevelopment cycle. Software usually goes through several phases&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;\(\[\text{Analysis} \rightarrow\text{Design} \rightarrow\text{Implementation} \rightarrow\text{Test} \rightarrow\text{Deploy} \rightarrow\text{Maintenance}]\)&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;It is important to stress that development of software is a dynamicactivity. We repeatedly change the software in production by layeringmore and more complexity/features on top of the system. We alsodynamically fix bugs in the software while it is in production.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The recent years, development tends to so-called Agile methods—wherethere are many small dynamic iterations of the software constructionprocess running all at the same time. We have social tooling in placewhich tries to achieve this (Scrum, Kanban,…), and we have technicaltooling in place to reach the goal (git, Mercurial,…).&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The “Maintenance” part is very expensive. Maintaining running softwarehas periodic costs associated with it. In a world where everything is aservice, we have to pay operators, pay for hardware resources,developers, and so on.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When we program, we try to remove errors early. We employ static typesystems, we do extensive testing, we use static analysis. Perhaps weeven use probalistic model checkers like QuickCheck, exhaustive modelcheckers like SPIN or prove our software in Coq. We know, inherently,that eradicating bugs early on in the software life cycle means lesswork in the maintenance phase.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But interestingly, all this only &lt;em&gt;raises&lt;/em&gt; the bar for errors. When wehave done all our hard work, the errors that do remain are all of thesubtle kind. These are errors which were not caught by our initialguardian systems. Most static type systems won’t capture the class offaults which has to do with slow algorithms or excessive memoryconsumption for instance. A proper benchmark suite will—but only if wecan envision the failure case up front.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The class of faults that tend to be &lt;em&gt;interesting&lt;/em&gt; is the class that cansurvive a static type check. The mere fact we could not capture it by astatic analysis in the compile phase makes the error much more subtle.Also, it often means they are much harder to trigger in productionsystems. If the fault furthermore survives the test suite it becomeseven more &lt;em&gt;interesting&lt;/em&gt;. The viral strain has a certain basic DNA whichmutated it so it could get past two barriers of correctness tests. Nowit becomes a latent bug in your software.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;Aside:&lt;/em&gt; I tend to absolutely love static type systems. I enjoy them alot when I program in Go, Standard ML, OCaml or Haskell. I am all forthe richer description that comes with having a static type system.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There is a great power in being able to say \(v \colon \tau\)rather than just \(v\)—exactly because the formerrepresentation is &lt;em&gt;richer&lt;/em&gt; in structure. Richer structure helpsdocumentation, makes it possible to pick better in-memoryrepresentations, makes the programs go faster and forces a more coherentprogramming model.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Yet, I also recognize that most of the errors caught by static typesystems are &lt;strong&gt;not&lt;/strong&gt; &lt;em&gt;interesting.&lt;/em&gt; They are of the kind where a simple runof the program will find them instantly.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;End of Aside.&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_concurrency_and_distribution_failures&#34;&gt;Concurrency and Distribution failures&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When systems have faults due to concurrency and distribution, debuggerswill not work. The problem is that you can’t stop the world and then goinspect it. A foreign system will inspect an answer in time or it willtime out. Many modern systems have large parts of which you have nodirect control anymore. Such is life in the Post-1991 era of computingwhere the internet defines the interface to your program and itscomponents. An Erlang system with two nodes is enough to be problematic.Even if I could snapshot one node, the other node will carry on.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The same is true for concurrency errors. They often incorporate raceconditions which must trigger. Attaching a debugger alters the executionschedule making the race condition disappear in the process. The onlyway to debug such systems is by analysing post-mortem traces of whatwent wrong—or by inspecting the systems online while they are running.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;To make matters worse, a lot of races only occur when data sizes areincreased to production system batches. Say you have a small writeconflict in the data store due to inappropriate transactionalserialization and isolation. If your test system has few users, thisconflict will never show up. And if it does, you will disregard it as aone-time fluke that will never happen again. Yet—on the productionsystem, as you increase capacity, this problem will start to occur. Thestatistical “Birthday Paradox” will come and rear its ugly head andyou will be hitting the conflict more and more often. Up until the pointwhere it occurs multiple times a day.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In conclusion, capturing these kinds of bugs up front is deceptivelyhard.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_the_erlangshell&#34;&gt;The Erlang Shell&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang shell is a necessary tool for producing correct software. Itsusefulness is mostly targeted at the maintenance phase, but it is alsouseful in the initial phases of development. A running Erlang system canbe connected to while it is running:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;literalblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre&gt;(qlglicko@127.0.0.1)3&amp;gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This provides a REPL so you can work with the software. But note thatthis is a REPL on the &lt;em&gt;running production system&lt;/em&gt;. If I run commands onthe system:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;literalblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre&gt;(qlglicko@127.0.0.1)3&amp;gt; qlg_db:players_to_refresh(1000). {ok,[]}(qlglicko@127.0.0.1)4&amp;gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I hook into running processes. In this case &lt;em&gt;qlg_db&lt;/em&gt; which doesconnection pooling towards the Postgres database. This allows me to goprobe the system while it is running to check for its correct operation.Any exported functionality can be probed from the shell.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I often keep a module around, named &lt;em&gt;z.erl&lt;/em&gt; which I can compile andinject into the running system:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;literalblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre&gt;(qlglicko@127.0.0.1)6&amp;gt; c(&amp;#34;../../z.erl&amp;#34;).{ok,z}(qlglicko@127.0.0.1)7&amp;gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This dynamically compiles and loads the &lt;em&gt;z&lt;/em&gt; module into the runningsystem. It makes the functions of the module available for systemintrospection and manipulation. When debugging hard-to-find bugs onsystems, you &lt;em&gt;need&lt;/em&gt; this functionality.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;And yes, if you want, Erlang nodes contains the &lt;em&gt;compiler&lt;/em&gt; applicationso they can compile modules.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In Erlang, linking is deliberately “as late as possible”. This meansyou can change software in the system while it is running. There is nolinker phase up front at compile time. Linkage is done when you callanother module. Yes, this costs performance. But on the other hand, itmeans you can always rely on the system calling the newest loadedversion of the module. The ability to hot-patch a system while it isrunning can help a lot. You don’t have to interrupt the system for smallfixes for instance. If you know that you only changed a single module inyour test build, you can opt to just push that compiled byte code toproduction and then inject it into that system. As long as yousystematically add the change to your standard deployment pipeline, thisworks.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The shell also provides a lot of nice tooling to help you when you arelooking for problems in a system:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;There is built-in job-control in the sense of the sh(1) shell. You canhave several shells open at the same time. You can reconnect to shells,either locally or remote. And you can kill shells which have hung forone reason or the other.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Erlang has built in trace capabilities. These provide DTrace-likebehaviour on the system directly without effort. Enabling tracing onlyimpacts the traced modules and it is generally non-intrusive (unless youmake a mistake when setting trace patterns, heh). You can mask events:only when this process calls. And only these two functions. And onlywhen the 3rd passed parameter is 37. The Erlang shell makes this allpossible dynamically on the running system.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Want to know what state a given process has? Fear not, you have onlineintrospection via the shell.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Want to know how many messages there is the inbox of a process? Fearnot…&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Want to insert a new log statement? Recompile the code and hot-deployit via the shell. Fear not…&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;And all this &lt;em&gt;without&lt;/em&gt; service interruption. And you get all this forfree, just because you picked Erlang as the implementation language.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Here is the thing: the first time you use the Erlang shell in productionto fix a hard-to-debug problem it becomes very very hard to live withoutit. I’d willingly give up static typing for the ability to look at therunning system. Problems that survive past the tests and into productiontend to be sinister and evil. And subtly elusive. You need a systemthere where you can go and inspect it, while the error is occuring inproduction.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;It is the same traits that made UNIX a success (and what makes Plan9alluring and appealing). Your system can be inspected and manipulatedwhile it is being developed and changed dynamically. Except that inErlang, we have much finer grained control over the running UNIX-processsince we can go inside it and inspect running processes inside the node.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Glicko2 Benchmarking (1)</title>
       <link>https://jlouis.github.io/posts/glicko2-benchmarking-1/</link>
       <pubDate>Sat, 16 Nov 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/glicko2-benchmarking-1/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;One of my hobby projects is to run statistics on Quake Live Duelmatches. I began collecting data around 1st of Feb 2013 and now I havescraped around \(2.5\) Million duel matches. This allows me toplay with different ranking methods on the players and gauge theirranking.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The ranking system I use is called Glicko2, devised by Mark E. Glickman(&lt;a href=&#34;http://glicko.net/&#34;&gt;http://glicko.net&lt;/a&gt;). The system is like the chessrating system ELO, except that it is newer and avoids certain problemswith ELO.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When ELO was conceived, you had to be able to run the calculations byhand. Glicko2 can use a computer and thus carry out much hardercalculations. So it tend to deliver better results. Glicko2 tracks threevalues for each player. His rating R, starting at 1500. His ratingdeviance, RD, starting at 350 is a measure of how much we trust therating R. If the RD number is small, we have strong belief in the ratingof the player. If it is high, we don’t yet know a lot about that player.As the player plays more matches and we learn more about the player, weshrink RD towards 0. Finally a value, Sigma, measures how much a playeris fooling the rating system. This allows us to compensate for quicklyimproving players so they don’t get ``stuck&amp;#39;&amp;#39; on a certain rating.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When considering a new rating for a player, we consider a weeks worth ofduels for the player. We update his R, RD and Sigma values depending onthe values from the previous week and the opponents he played against.If the player has a high RD for instance, his rating is moved more perwin or loss since we know less about him yet. This means we quickly findthe skill level of a given player.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The system I have made is written in Erlang. This choice has been veryfruitful. First of all, I have a system which was easy to write andscales well, even though I don’t really need that. Second, the faulttolerance of Erlang has helped me a lot. The system has been very robustdue to the fault tolerance of Erlang. Usually I don’t care about thesystem. It takes care of the network being down or Quake Live beingupgraded by itself.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Storage is handled by Postgres. If you need a database that just works,then picking Postgres is rarely a problem. Furthermore, the completedata set is less than 6 gigabytes, so almost any kind of store wouldwork. But Postgres is a simple choice due to its reliability and featureset.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang system works well for the fetching of matches, and fordisplay of match scores and so on. But I need to carry out some tuningsof the Glicko2 parameters. This means I will run through my\(2.5\) million matches many many times and thus the speed atwhich I can run Glicko2 matter. I have an Erlang implementation for asimulated annealer and ranker. But since it is heavyweight numericalprocessing—not an Erlang strength—I need to find another language fordoing that.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;So there are three things I need to know:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;How fast can I run the Glicko2 ranking codes? That is, how quickly canI execute the main loop for a single simple ranking. This will be neededto understand how much I could hope to gain by going to another languagein the first place. If I can’t get enough speed, I can simply abort theprocess right here.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I have \(2.5\) million matches and need to process them all.Thus the problem is switching from being CPU-bound to being memorybound. I need to find out if this change affects the processing speed ofother languages. Again, if I can’t do it faster, then I need to abortthe task.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I need to run the \(2.5\) million ranking runs either in analgorithm running simulated annealing or a gradient search. This meanspotentially millions of runs times the \(2.5\) million rankingruns. This is the long-term goal I wish to reach. In this part I requirethe speed much more than in the other parts.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A slightly smaller problem is that my current ranking runs requirememory proportional with the number of matches. When I had 400.000matches it was easy to fit in memory. But now, I am running up against abarrier of the machine doing the computations (it doesn’t have too muchmemory, it is an old machine).&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In the following I present some Timings. These are run on a Linux Laptopworkstation, where it is plugged into power and runs full processorspeed. The machine is a ``Intel® Core™ i7-3720QM CPU @ 2.60GHz&amp;#39;&amp;#39;which is an Ivy Bridge machine, 4 cores, two HTs per Core.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I intend to tune on this machine, so it is paramount the rankings arerunning fast on this machine.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Erlang Glicko2&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://github.com/jlouis/erl-glicko2&#34;&gt;erl-glicko2&lt;/a&gt; The Erlang systemitself can run a single Glicko2 round of one player against 3 players in22\(\mu{}\)s. The benchmark in Erlang is carried out byrunning the test 300 times and then averaging. This batch size seems tobe quite stable.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The speed figure of Erlang is with the standard BEAM bytecodeinterpreter. And the code is straightforward with no tuning whatsoever.With \(2.5\) million matches it takes just around a minute torun through them all, which is acceptable. But since I am to run fasterthan that, I wanted to know how much faster I could go.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Compiling with HiPE gives 8\(\mu{}\)s. This is much better andfar more in the area where I would like to be. But perhaps we can dobetter by switching the language.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Ocaml Glicko2&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://github.com/jlouis/o-glicko2&#34;&gt;o-glicko2&lt;/a&gt; One of my favoritelanguages when I need fast processing is OCaml. The language has a largenumber of beneficial properties—static typing, a native code generatorproducing fast executables, a good module system and a nice eco-system.So naturally, transcribing the code from Erlang to OCaml has to betried.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The code is quite straightforward to change from Erlang into OCaml.There are few places in the code base where we use anything but &lt;em&gt;float&lt;/em&gt;types, so it is easy. The only slight problem was a missing parenthesisgroup which made a subcomputation produce the wrong result. Luckily, Ihave extensive tests so it was caught quickly.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Note that the particular error is one of those which will not be caughtbe a type system. In numerical code, everything is of type &lt;em&gt;float&lt;/em&gt;anyway, so there is no way I can hope to catch this kind of errorstraight away. Type systems help a lot with symbolic processing, butthis task is not one which has that property.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The OCaml code is written in idiomatic style. Functional, closures, andso on. I could opt for a more imperative style—which Ocaml allows—butfor what purpose?&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I use the &lt;strong&gt;Core_Bench&lt;/strong&gt; module from Janes St. to do my benchmarking. Thenice thing is that this tool predicts the batch size to use and also hasprediction that avoids making the wrong conclusions. The OCaml bytecodeinterpreter clocks in at 28\(\mu{}\)s. This result somewhatsurprises me. I had expected the run to be faster than Erlang. But Iguess more time is spent optimizing the Erlang interpreter than theOCaml bytecode interpreter and code generator.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Running native yields a time around 2\(\mu{}\)s. This numberis really good. If we are to process \(2.5\) million matches,we can do so in \(2.5 \times 2\)\(\mu{}\)s (assumingno cache hierarchy) or \(5\) seconds. Much better than theminute it would require in Erlang.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Yet, the problem here is that the OCaml core is not parallel. I wouldneed to cut up the data set into pieces and then run an OCaml processper core. There is no need to do that in Erlang. So even though theresults will clock in faster, the problem is that I will need more workto fetch data in parallel later on. So parallelism might become aproblem going forward.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Go — Glocko2&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://github.com/jlouis/glocko2&#34;&gt;Glocko2&lt;/a&gt; Naturally, I had to try Golangnext. This language is interesting because it has nice semantics, fixingmost of the things I hate about C. It compiles to native code with astandard slightly optimizing compiler. And it supports multiple cores inits runtime, which is needed if I want to get parallelism inside asingle process later on.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Writing the code in Golang is a chore. Productivity is definitely slowerthan in Ocaml since you have to type more and waste precious timereframing the nice functional problem into imperative code. Even thoughthis was the last thing I implemented, it still took about twice as longas the OCaml implementation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;Do note: My imperative skillset is there, but I don’t write muchimperative code nowadays. This could be a factor in the slower writingspeed. However, writing last should be a help, rather than ahinderance.&lt;/em&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;What is so nice about Golang is the tooling. I set up &lt;em&gt;go test&lt;/em&gt; early onin my editor, so when I saved a file it would automatically compile andrun tests. See &lt;a href=&#34;http://github.com/eaburns/Watch&#34; class=&#34;bare&#34;&gt;http://github.com/eaburns/Watch&lt;/a&gt; for the tool I use inAcme to do this. This meant I could start by writing down all the testcases and then go work on the implementation afterwards. As more andmore of the code base began to work, I had fewer and fewer failing testcases.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Benchmarking can be done with the Go Testing tools as well. It alsocomputes a batch size and gives you predictive results, like in Ocaml.But in this case, it is built into the default tooling. I cannot&lt;em&gt;stress&lt;/em&gt; how important it is for a language to have nice access toprofiler tooling and so on inside the default language distribution. Thefact that the build tool does testing and benchmarking as well bydefault is just awesome.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Being Go, the compile times are faster—but this doesn’t matter for thisproblem as the compile times are ``not noticable&amp;#39;&amp;#39;. Go clocks in at1\(\mu{}\)s. About twice as fast as the OCaml solution. Thisis with the default compiler written by Ken Thompson initially andimproved by many other people.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Recap&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;So we have:&lt;/p&gt;&lt;/div&gt;&lt;table class=&#34;tableblock frame-all grid-all stretch&#34;&gt;&lt;caption class=&#34;title&#34;&gt;Table 1. Breakdown of the different implementations running speed&lt;/caption&gt;&lt;colgroup&gt;&lt;col style=&#34;width: 50%;&#34;/&gt;&lt;col style=&#34;width: 50%;&#34;/&gt;&lt;/colgroup&gt;&lt;thead&gt;&lt;tr&gt;&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;Language&lt;/th&gt;&lt;th class=&#34;tableblock halign-left valign-top&#34;&gt;Efficiency (\(\mu{}\)s)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Ocaml bytecode&lt;/p&gt;&lt;/td&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;28&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Erlang bytecode&lt;/p&gt;&lt;/td&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;22&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Erlang HiPE&lt;/p&gt;&lt;/td&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;8&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Ocaml native&lt;/p&gt;&lt;/td&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;2&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;Go&lt;/p&gt;&lt;/td&gt;&lt;td class=&#34;tableblock halign-left valign-top&#34;&gt;&lt;p class=&#34;tableblock&#34;&gt;1&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There is no solution which totally aborts at this point. I already havean Erlang implementation, and the numbers may change around when we addthe next layer—processing 2.5 million matches. Before I add that andhave the option to do profiling, I’d rather not try to hand-optimizethese results too much right now.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Tuning Tricks&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When you revisit the same algorithm in multiple languages, you seepossibilities for optimizations all over the place. There are somesubcomputations, the &lt;em&gt;g&lt;/em&gt; and &lt;em&gt;e&lt;/em&gt; functions, which I don’t know if it isworth to compute once and then stash away in memory. I could probablylower write memory pressure and GC by recomputing them when I need them.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Also, all of Glicko2 runs on a scaling factor of &lt;em&gt;173.7178.&lt;/em&gt; This meansthat before doing anything with the given R and RD values, you scalethem down by this factor. All computation are carried out on thedownscaled numbers. The final step is to upscale everything again. Atrick which I am seriously considering is to scale down everythingbefore starting my runs. This avoids a down scale and an upscale in eachloop and this would help a &lt;em&gt;lot&lt;/em&gt; for the larger computations where manyruns are needed.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;One of the major Glicko2 steps is to find a root of a function. I amcurrently using a root-finder, called Ridder’s method. This finder isquite fast, but it is also the major slowdown in the runs. When I firstimplemented the OCaml variant, I picked a different root-finder bymistake. This meant that it ran in 0.6\(\mu{}\)s, sodefinitely this part of the code base is the contending one. It alsosuggests that the Golang implementation is handling this partdifferently than the OCaml code and there is definitely room forimprovement in the OCaml code.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Parting words&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;In the next phase, the code to read, parse and compute on 2.5 millionlines of code has to be written. I have no time frame for doing so, as Iam mostly doing this ``for fun and entertainment&amp;#39;&amp;#39;. I am pretty sure youcan optimize the code bases like mad, but there is little reason to doso before the other parts have been implemented. The problem willquickly be memory bound, so the interesting things in speeding it upwill be in-memory representation.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;My initial ideas is to store data in a vector-like format. In Erlang Iuse an ETS-table, but this incurs a hash-table lookup a large number oftimes. My profiling shows I spend 50% time in &lt;em&gt;ets:lookup_element/3&lt;/em&gt; inErlang. So to go faster, I need to pack these data better in memory. Itmight very well be that the numerical code is not the hottest path inthis program at all. So I hesitate to optimize it.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;This is also the reason why I considered BER MetaOCaml, but lostinterest in using it again before I know that I can get decent speed onthe other parts. There are ways to make this parallel even thought theOCaml runtime is not. Perhaps I can work around that, but I will notethe extra cost in time to do so.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I also considered Haskell. Given Repa or Accelerate, you can probablespeed up the computation and move it to the GPU. It is an interestingproject, but it requires a completely different approach to the problemat hand. One could also use the Erlang OpenCL bindings to achievesomething like this.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Finally, if you were a company, &lt;strong&gt;none&lt;/strong&gt; of this would have been needed. Ialready had the Erlang code for tuning. I would just have had to leasethe next machine size in Amazon Web Services for 24 hours. I don’t needto run tuning that often. Once a year or so is perfect. And I can runweekly updates in a minute. If I cut the dataset into 10 pieces, andload it from Postgres a little bit at a time, then I could definitely dothis inside a 3 minute window. This is hardly a problem. It is not worthdoing this from a Cost/Benefit perspective. And frankly, writing thecode in Erlang is probably faster than writing it in OCaml or Go for me.&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>On Logbooks</title>
       <link>https://jlouis.github.io/posts/on-logbooks/</link>
       <pubDate>Mon, 11 Nov 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/on-logbooks/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;My friend, Michael T. Richter, presented me with a nice concept fromengineering. The &lt;em&gt;logbook&lt;/em&gt;. The concept is extremely simple: you keep alog of your work, so you can refer back to it later. Yet, there arerelatively few in Computer Science who does that, which is a sad stateof affairs.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The odd thing is that most computer scientists do know the importance oflogging in an application. You see these elaborate logging frameworksthat can log at different log levels, can forward logs between machinesand so on. Yet—it looks like the CS people forgot that the same loggingcould apply to your own work.&lt;/p&gt;&lt;/div&gt;&lt;hr/&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;My Log comprises two files. One for work and one for personal projects.In each file, I keep track of dates. The file is pure text, though I useutf-8 encoding, so I have access to full Unicode, which I exploit fully.I have the following in the file in the acme(1) editor:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;literalblock&#34;&gt;&lt;div class=&#34;content&#34;&gt;&lt;pre&gt;&amp;lt;date +%Y-%m-%d&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;which can be run to enter the current date at the cursor position. Itend to jot down the projects that are &lt;em&gt;in progress&lt;/em&gt;. My log is not aTODO list! I’d rather track stuff I have done than stuff I don’t havetime to do. Having a log gives me some immediate benefits:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;I can run &lt;em&gt;grep&lt;/em&gt; on old entries. This is tremendously efficient. Ioften write down shell-oneliners, R scripts, hostnames too volatilefor &lt;em&gt;.ssh/config&lt;/em&gt;, results from benchmarks, test failures, meetingoutcomes and so on. I can find old stuff as long as I remember that Iwrote it down at some point in time. I also keep links to papers, IssuesI am working on, source files and so on. My editor of choice, acme(1),allows one to write &lt;em&gt;file:/REGEX&lt;/em&gt; to open a file and then perform asearch within that file based on the regular expression I give. Ineffect, I have full history tracking.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I can answer the question ``What did you do two weeks ago?&amp;#39;&amp;#39; withease. It also means I can gather knowledge about what kind of work I amcurrently doing and for what purpose.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The log acts as a tool for improving the process. By keeping track ofwhat is being done, I can look back and see what can be done better.This allows me to run an iterative quality improvement process on mydevelopment.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The log allows me to use the “Hemmingway trick”, which is leaving asentence before it is done and finished. It is then easier to go backand pick up from where you left. By tracking what is currently inprogress, I have an easier time entering flow again on the piece of codeI am working on. Switching ``context&amp;#39;&amp;#39; is also way easier. Since I canwrite down where I am currently on one part and then switch to anotherpart.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Since the log tracks stuff in progress, I can quickly figure out if Iam starting too many new projects and not finishing any of them.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The log allows me to clear my brain once in a while since it has beendocumented elsewhere.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;It is way easier to have &lt;em&gt;focus&lt;/em&gt; with a log of what is being done,vastly improving efficiency and output.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Personally, I think the most important part is that this has vastlyimproved my process. Especially when hunting for bugs. I tend to writedown what I know and what hypothesis I have. Then I try to devise someexperiment that can cut through the hypothesis and cleave up thepossibilities. Bug finding becomes much faster when you approach it likethis.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Another part of the process which also has improved is the approach towriting new code:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;I try to document the purpose of the new piece of code. That way, Imake sure I know why it is important to implement this part—and Idocument that for future reference.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;I often write down how hard I think the code is to complete. Thisgives me a benefit later when I can go back and see if I was right orwrong with the estimate.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If we had multiple solutions, that is documented.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If a test comes up with a surprising result, that is documented.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;As a consequence, you do less work and better quality. The concept ofthe &lt;em&gt;logbook&lt;/em&gt; is hereby passed on to the reader.&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Eventi</title>
       <link>https://jlouis.github.io/posts/eventi/</link>
       <pubDate>Wed, 30 Oct 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/eventi/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;So, listening a bit to “The Civil Wars” this afternoon cooked up therest of eVenti. This blog post is brought to you by Maurice Ravel, andMorcheeba however.&lt;sup class=&#34;footnote&#34;&gt;[&lt;a id=&#34;_footnoteref_1&#34; class=&#34;footnote&#34; href=&#34;#_footnotedef_1&#34; title=&#34;View footnote.&#34;&gt;1&lt;/a&gt;]&lt;/sup&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The eVenti system is a simple Erlang-implementation of the venti(8)system famous from Plan9. The idea is very simple: We can store data inVenti and the data becomes addressed by its SHA1 checksum.footenote:[Ishould probably change this later, but for compatibility reasons westick to it…] This is called a Content Adressable Storage (CAS) becauseContent is—you guessed it—addressed by the checksum of the content.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;div class=&#34;title&#34;&gt;Immediate effects are:&lt;/div&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;Storing the same data twice has no effect, deduplication is automatic.You can’t accidentally destroy data in a Venti-store, because writes areidempotent and happens at most once.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Data storage is forever. And it is excellent for archival storage andbackups.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Security is peculiar. I can give almost everyone in the world readaccess—and yet they will be unable to guess a key (called a &lt;em&gt;score&lt;/em&gt; inventi-speak). This makes it possible to use the store as a dead-drop formessages and have others retrieve them at a later stage. Write access ismore problematic. While nobody can destroy my data in venti, I can’tprotect against an enemy adversary filling up my store with junk. Yet,the properties of implicit integrity is quite nice to have.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The Erlang implementation is very simple. First, we employ the &lt;em&gt;ranch&lt;/em&gt;acceptor pool to handle many simultaneous TCP connections. The protocolit binary, but we can use Erlangs ability to match on binary patterns tohandle that easily. To handle the backend storage, we employ &lt;em&gt;eleveldb&lt;/em&gt;which is LevelDB bindings to Erlang.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Whenever a client connects, we spawn a process and loop over standardrequest/reply patterns for that client. A single &lt;code&gt;gen_server&lt;/code&gt; instannceruns the calls to and from the database. All code we wrote, includingsource, empty lines and comments are 435 lines of code. Erlang tends tobe wonderfully succinct.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;An interesting notion is that all commands in the protocol have &lt;em&gt;tags&lt;/em&gt;which identifies the message. A tag in a request is reflected in theresponse. It is the same as correlation id’s in the AMQP protocol forinstance. And it allows for aggressive pipelining of requests. If onlymore protocols had this nice construction built in.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;What I &lt;em&gt;love&lt;/em&gt; about the model is that venti(8) is a very simple storageendpoint—yet it plugs so well into other subsystems. There is aunix-feeling to Plan9 tools, except they are one-level-up in thedistribution chain. The key insight is that with venti, you have aself-contained system you can use to build other systems on top of. Andby picking a system that already exists, you leverage the advantage thatthere are already tooling out there which can read and write from thestore.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There are some obvious extensions to eVenti. First, we can triviallyexchange leveldb for riak. This will provide proper secure backup ofdata by running a cluster of machines and by copying data out tomultiple machines. Note that the fact that Riak is a AP store is noproblem to us: We store immutable data with idempotent writes. Conflictresolution is simply “pick one at random since they are equivalent byconstruction”.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;My intention is to use eVenti as a building block. I have a weakness forMerkle-tree constructions and immutability in general. Plugs to systemslike Datomic, Dropbox, and Bitcoin. Note that you can run an event-logas a Merkle tree, in the same sense as a Bitcoin block-chain.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Suppose I and a friend run eVenti servers. If I have write access to hisserver, I can make encrypted backups at his place, not entirely unlikeColin Percivals tarsnap project. Co-incidentally, it will also provide anice foundation for a secure encrypted chat service with long-termstorage. It will be so simple to link attachments into the chat. OrChess games. If I know the SHA1 of our game, I can extend it with a moveand send the new SHA1 to you. Nobody else knows our game. But if I sendyou a SHA1 of another game, you can walk the chain and get at all moves.Over time the DAG in venti will form a nice opening book as well.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;A system like venti is a necessary tool nowadays. The pendulum has swungtotally to the point where every service we use is centralized. Tenyears ago, we were running lots of P2P systems: Bittorrent for instance.It is time we—the internet—push the pendulum in the other direction.This means we need to be the arbiters of our own data again. Not pushthe data to some irritating insane third party company who will like tosell the data for money&lt;sup class=&#34;footnote&#34;&gt;[&lt;a id=&#34;_footnoteref_2&#34; class=&#34;footnote&#34; href=&#34;#_footnotedef_2&#34; title=&#34;View footnote.&#34;&gt;2&lt;/a&gt;]&lt;/sup&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;No company will build the decentralized structure, unless they have abusiness plan for it. And it seems very few companies in this space haveany other business plan than to sell your data back to you for money.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Next, I want to see how I can leverage the Plan9 9p protocol and FUSE toturn data into a filesystem I can mount. Imagine having a chatconversation where you can cd into a directory in the filesystem andautomatically have access to all the attachments of that chat.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But I do think I need more than 435 lines to do that. Perhaps 1000.Embrace Erlang :)&lt;/p&gt;&lt;/div&gt;&lt;div id=&#34;footnotes&#34;&gt;&lt;hr/&gt;&lt;div class=&#34;footnote&#34; id=&#34;_footnotedef_1&#34;&gt;&lt;a href=&#34;#_footnoteref_1&#34;&gt;1&lt;/a&gt;. I have a weakness for Gaspard de la nuit :)&lt;/div&gt;&lt;div class=&#34;footnote&#34; id=&#34;_footnotedef_2&#34;&gt;&lt;a href=&#34;#_footnoteref_2&#34;&gt;2&lt;/a&gt;. Hello every company in existence.&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Glicko 2 Benchmarking</title>
       <link>https://jlouis.github.io/posts/glicko2-benchmarking-2/</link>
       <pubDate>Wed, 30 Oct 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/glicko2-benchmarking-2/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Glicko2 is a ranking system for duel games. I use it to rank Quake Liveduels. The idea is to find a value, the &lt;em&gt;strength&lt;/em&gt; of a player, called Rin the system. The higher the R value, the better the player.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;How does Glicko2 estimate R? It looks at historical data and usesbayesian methods to estimate the current strength of a player. Like allother systems, there are parameters we can tune for a set of players anda set of duels:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;What initial R value should we pick for new players? We could pick1500 as the base, but it may be that there are better initial valuesthan this.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What initial RD value should we pick for new players? The RD valuemeasures a &lt;em&gt;belief&lt;/em&gt; in a given R-value. A large RD means we haverelatively little information and hence can’t trust the R value as muchfor rathing purposes.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What about the initial Sigma-value? The Sigma-value is used to adjustratings for players which are consistently fooling the rating system. Itaccounts for the situation where a player has been ``locked&amp;#39;&amp;#39; to a givenrating and then suddenly improves. In other rating systems, it wouldtake a long time to move that players R value to the correct position.But Glicko2 will detect this and adjust the Sigma for the player,allowing for greater R-strides.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;What about the value of Tau? Tau is a global value which controls howmuch power Sigma has. Games with high random variability needs a low Tauaround 0.2 to account for randomness in games. Games with lowervariability can run with higher Tau-values. Perhaps as high as 1.2 atmaximum. In game types with high Tau-scores, there is very little randombehaviour. Hence a win or a loss is more decisive and Sigma shouldadjust with a greater factor.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The 4 different values spans a 4-dimensional space. We can try to tunethe values for the game type we are looking at. By doing so, we can hopeto find good values which optimize the ranking system to the game type.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_nelder_mead_numerical_optimization&#34;&gt;Nelder-Mead numerical optimization&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;There are many optimization algorithms. The original algorithm when Ioperated in pure Erlang was quite computationally intensive. I used theconcept of &lt;em&gt;Simulated Annealing&lt;/em&gt; as an optimization heuristic. Thisalgorithm works well, but requires many computations in order to findgood values.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I had experiments of Glicko2 computations in Erlang, Go &amp;amp; OCaml. Giventhat the fastest Erlang code runs a round in 8us, OCaml in 2us and Go in1us, I decided to focus on Go for the next round of work.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I want a more intelligent search for an optimum. One algorithm isNelder-Mead from 1965. This algorithm has some trouble in certainsituations. And it may converge to a wrong point. But it often workswell in practice. So I set out to implement the algorithm for Go. Theefforts are here, including tests and benchmarks:&lt;a href=&#34;http://github.com/jlouis/nmoptim&#34; class=&#34;bare&#34;&gt;http://github.com/jlouis/nmoptim&lt;/a&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;NM is nice for our ranking work since it does not need numericalderivatives of the function being computed. Rather, you start with a&lt;em&gt;simplex&lt;/em&gt; which you then iteratively move around. You can imagine afishing net spanning the whole sea. NM proceeds by moving the fishingnet according to some rules in order to find the fish you are searchingfor. In this case the minimum of the function at hand.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Nelder-Mead by itself is not easy to make parallel. But the rankingfunction is trivially parallelizable. So I opted to do operations inparallel and then speed up the ranking code. By using sync.WaitGroup inGo, I immediately got to around 500% CPU usage on an 8 core machine. Sonow I am blocked on speedup. Getting 5/8 of the cores to do meaningfulwork and a factor of around 5 in speedup is nice. My ranking runs areabout 5 times faster in wall-clock as well. And that is disregardingother possible optimizations.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Furthermore, we find a good value in 22 iterations of Nelder-Mead with45 function evaluations. I guess it was not that important to speed upthe computations after all since Erlang would have been able to runthis, albeit in hours rather than minutes. Go completes the run in inabout 3 minutes on my current Ivy Bridge Core-i7 laptop, which is a finespeed for 2.5 million quake matches. It also ranks in around 925ns permatch which is around the numbers I got in my Glicko2 benchmarks for asingle test match.&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&#34;sect1&#34;&gt;&lt;h2 id=&#34;_the_nextsteps&#34;&gt;The next steps&lt;/h2&gt;&lt;div class=&#34;sectionbody&#34;&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I can now optimize in Go, but there are still more work to be donebefore it is on par with the Erlang code:&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;We need to be able to rank pairs of \{Player, Map}. This is rathereasy.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;The prediction code only runs on the last round out of 99. It shouldpreferably run prediction on the last 4-5 rounds instead so thepredictions even out over a larger area. This will account for a singleround of matches becoming too crazy.&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Ranking expected scores need some clamping which I am not doingcurrently, but that should be easy to add as well.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>Why I use erlang.mk</title>
       <link>https://jlouis.github.io/posts/why-erlang-mk/</link>
       <pubDate>Mon, 28 Oct 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/why-erlang-mk/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Here is our typical Erlang project. And note we are on a pretty slow MacOSX filesystem and a 5400 RPM disk. Not the fastest in the world. If Irun a rebar-compile from cold, we get the following a timing of 26seconds. Doing the same with erlang.mk is 24 seconds. Note thaterlang.mk only uses one thread, whereas rebar is parallelizing the buildand is using all 4 cores in the machine. But erlang.mk only spawns theerlc compiler once per directory, and only if it needs to—no changemeans no spawn.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;But if we have already compiled the code, the numbers are muchdifferent. When compiling from warm, it takes rebar 9 seconds to figureout that there is nothing to do in the project. erlang.mk does the samething in 0.2 seconds.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;When developing, I don’t want to wait on the compile to finish all thetime. I want it to be proportional to the amount of change in myrepository, not on the complexity of the software project.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The other reason is that make(1) is the right tool for the job. Most ofthese other tools are reinventions of the thing make(1) does. And it isvery hard to even contend with a tool that has survived so many yearsand is so archaic.&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>An Evil Postgres Bug</title>
       <link>https://jlouis.github.io/posts/evil-postgres-bug/</link>
       <pubDate>Mon, 07 Oct 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/evil-postgres-bug/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;So, I have this QLGlicko project. It consists of a web scraper whichtakes in duel matches played in the game of Quake Live—and stores themin a Postgres database. These duels are then analyzed and I run theGlicko 2 (see &lt;a href=&#34;http://glicko.net/&#34; class=&#34;bare&#34;&gt;http://glicko.net/&lt;/a&gt;) ranking system on them to tell peoplewho are currently the best player on a given map.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The system works well, but I was tired of maintaining it on a Linuxmachine for several reasons. One, Linux is hard to maintain and thingschange underneath faster than I like. Two, I have much more experiencemaintaining FreeBSD machines. Three, I can get proper built-in ZFSsupport on FreeBSD. Hence I decided to move the database onto FreeBSD.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Most of the migration went well. I dumped the database, installedFreeBSD, installed Postgres 9.3 (to avoid having to toy with SysV sharedmemory). Tuned the database. And tried to import. First problem is thatLinux used the fake locale called “en_dk.utf-8”—so I had to fake itand install that. Next problem was that I used the “uuid-ossp”EXTENSION in Linux. This one has several problems on FreeBSD, mostlyrelated to PIC code and the fact that it will crash the database.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;So I changed the code to &lt;em&gt;inject&lt;/em&gt; the UUID data rather than producing iton the database side. And then I suddenly had duplicate key constraintproblems on an UNIQUE INDEX. Running SELECT queries showed no suchtrouble with the index and there were no entries with more than a singleentry. This is to be expected due to the index being UNIQUE. But theinsertion or update code would soundly fail. I was wondering what wentwrong and began digging.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Here is what happened: the “uuid-ossp” code had managed to insert arow into the database before it crashed. So this went under the radar ofthe index and now we had trouble! There is an extra entry in thedatabase—violating the index—but it does not detect that.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Worse, when we query, the data can be served from the index alone, sincemost data in the table are frozen. This means we begin getting reallyevil and odd violations.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;Running a DROP on the index and then trying to recreate the index againmakes the error show up. And now I understood what went wrong.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;The solution was pretty simple: Restore the database from a backup.Remove any trace of “uuid-ossp” and then start the database again. Nowthe index works as expected and the database doesn’t crash.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;TL;DR—Beware of extensions that doesn’t work on your platform of choice!&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
     <item>
       <title>An Initial Post</title>
       <link>https://jlouis.github.io/posts/an-initial-post/</link>
       <pubDate>Wed, 02 Oct 2013 00:00:00 +0000</pubDate>
       
       <guid>https://jlouis.github.io/posts/an-initial-post/</guid>
       <description>&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;I tend to stir up things over on blogger, mostly writing the blog&lt;a href=&#34;http://jlouisramblings.blogspot.com/&#34; class=&#34;bare&#34;&gt;http://jlouisramblings.blogspot.com/&lt;/a&gt; —but I am considering writing andusing Medium instead to provide stuff, since the platform just seemsnicer. My Ramblings are mostly-technical and they tend to contain a lotof code in them, but the way I tend to add new blog posts is somewhatindirect. I write the post itself in my trusty Acme editor—asmarkdown—and then I convert that into HTML which I then push in on topof Blogger. I almost never use the editor in Blogger because I hate it.So writing on Medium is an attempt. An attempt to see if the platformwould be a nicer way to write posts and if I would prefer it to writingin the Editor.&lt;/p&gt;&lt;/div&gt;&lt;div class=&#34;paragraph&#34;&gt;&lt;p&gt;&lt;em&gt;Aside from 2018:&lt;/em&gt; In 2013, Medium was a quite nice platform. But overthe years, they destroyed the platform totally, making it a platformwhere you have to pay in order to read posts and entries. It was freeoriginally.&lt;/p&gt;&lt;/div&gt;</description>
     </item>
   
 </channel>
</rss>
